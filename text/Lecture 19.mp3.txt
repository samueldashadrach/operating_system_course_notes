{"text":"So, welcome to operating systems lecture 19. So, so far, we were looking at how the operating system represents and manages processing. So, we said that an operating system has a structure called PCB, the process control block for every process. On x86, this is the struct proc that we were looking at last time. And some of the important fields we looked at were, you know, each process has a pointer, which is of type page directory entry. So, this is a pointer which will be a page sized, which will point to a page sized allocation, which will be the page directory. Right? And that page directory will have more pointers to the second level page tables. And those page tables will have pointers to the actual pages. And so, this entire structure is private to every process. So, every process has a private page directory, private second level page tables, and private pages. Right? So, assuming we are not doing optimizations like copy on write, et cetera, I mean, conceptually speaking, each, each process has a private address space. So, it has a private hierarchy of the page table and the physical pages themselves. Each process has a private stack, case stack. Right? And once again, case stack is allocated from the kernel heap. And it's also a page sized entity in the x86 kernel. So, just to, just to, and we last time discussed why a page sized case stack is enough. We said the programmer can be careful such that the stack never goes beyond one page. Right? And the way that can do, it can do that is basically ensure that the call depth is bounded, that the amount, the size of local variables is bounded, that asynchronous interrupts cannot be received while an asynchronous interrupt handler is running. Right? So, you cannot just have asynchronous interrupts causing trap frames to get pushed. Right? So, these three things basically ensure that case stack remains bounded. And once again, case stack is private for a process. And so, just to give you some, a fact point, a point of data, Linux kernel, for example, uses a case stack of eight kilobytes. Right? So, not, not really big. Right? So, x86 uses four kilobytes, Linux uses eight kilobytes, and, and this amount of stack is usually sufficient for whatever the kernel wants to do. All right. This is a, yes, there's a question. Yes. So, let's say, you know, a programmer writes a recursive program, let's say just simply writes a recursive factorial program, and your stack depth is limited by whatever you have said here, at the page size, then will your stack overflow? Yes, it will overflow. So, what does that mean? A kernel developer should never write a factorial program inside the kernel. Right? There shouldn't be a function which is, you know, recursively going to unbounded depth depending on the user input. It shouldn't be possible. Right? A user program also does not have an infinite stack. Right? So, even if you write a, a user program has a larger stack than the kernel, the case stack, but it's not infinite either. Right? So, even if you, so there is actually a limit to how much recursion you can do, even in the user space. But it's much larger than what you can do in the kernel space. Sir, we are handling the external interrupts. Okay. Well, I said that we disable interrupts while we are executing an interrupt handler. And when the interrupt handler is running, can you actually switch, switch processes? Right? Or switch, switch the kernel stack, and then you can move there. Yes, you can. All right? But it was, the switch will not re-enable interrupts. Interrupts will get re-enabled only when you go back to user mode. But then... Sure. So, what will happen is, let's say process P1 is running, and an interrupt occurred. Process P1 starts running in kernel mode on the kernel stack, with interrupts disabled. The kernel stack gets switched. The new kernel stack, P2's case stack, is still, because P2 starts running in its kernel mode on P2's case stack, but still the interrupts will be disabled. It will be disabled for the duration of the switch, right? And then as soon as you go back to the user mode, you're back again, right? So how does the timer, how do the interrupts get enabled when you go back to the user mode? Because when you actually do a return from trap, so you pop off all the registers, and then you execute the irate instruction. And recall, the irate instruction pops off E flags, right? So the flag in E flags, which indicates that the interrupts are disabled or enabled, gets re-initialized based on the user value. And so now, when you're in user mode, you're executing with interrupts, whatever the... In general, you will be executing in user mode with interrupts enabled, right? Of course, now the user, if it makes a system call, then the system call need not disable interrupts. But if another timer interrupt occurs while you are executing in user mode, then again, you will execute with timer interrupts disabled, right? Interesting. So another question I have for you. Should a user mode program be allowed to disable interrupts? No. Because if a user mode program is allowed to disable interrupts, you can just take control of the system, right? So how does the architecture ensure, or how does the OS developer ensure that a user mode program cannot disable interrupts? So the CLI instruction, that's the only way to modify the bit of the E flags, is a privilege instruction. And so if the user ever executes that instruction, what will happen? An exception will get thrown, and the kernel exception handler will get called, and the kernel exception handler may just kill the process for what it did. There's another question? Okay. All right. Okay. So that's kstack. And now, trap frame. So we said that each PCB on XP6 also has a pointer to a trap frame. And this trap frame is basically nothing but it contains all the registers in user mode just at the time of entry to the kernel. And this is a nice thing to have because later if you want to refer to these registers for either arguments or anything else, or return value, then you can do that using the trap frame. And the trap frame is always pointing within the stack, within the kstack. In fact, okay, we're going to see exactly where it will point all the time. A trap frame for a saved process is always valid. A trap frame for a runnable process is always valid. A saved runnable process is always valid. The trap frame for a running process, a process that's running in user mode, especially, is not valid because it will get overwritten as soon as you come from user mode to kernel mode. So whatever the contents, it's completely immaterial. And then we said there is another pointer called context. And this context is basically saving the state of the kernel thread of that process. So when you came into the kernel mode, you executed some functions, and then at some point you called the switch function, which we saw last time. And the switch function is going to create this structure called context, where it's going to save all the callee saved registers and the return address, that's the EIP, on the stack, point context to that location, and then switch to another process's context. So if I look at the stack of any process, K-stack, so let's say this is the K-stack. I'm calling this the bottom. This space from context to K-stack is not used. And this is the top of the K-stack. So this is what top is equal to bottom plus 4096, 4 KB. So we know that it's a fixed size stack. So you K-alloc a stack. So that's what you got as a pointer to K-stack. Then you said, you know, plus 4096, that's my top. That's what you're going to feed into the TSS. And so in every trap, all these values are going to get pushed first by hardware, and then by your interrupt handler instructions. And that's where you want to set up your trap frame pointer. So this is the trap frame pointer, and you can look at all these fields from the trap frame. In fact, you didn't really need the trap frame pointer, because you already know. If you know K-stack, you can calculate TF by simply saying K-stack plus 4096 minus whatever is your size of trap frame. Right? It's always, it's always at a constant offset from K-stack. But just for convenience, let's just have a separate pointer in the PC, not a big deal. Also we said that, and also these values get pushed by the interrupt handler. And the interrupt handler ensures that the next sort of return address should be this address of this function called trap rate, right? And we said that one way to do that is just make sure that, arrange it as a function, and then make a call to wherever you want to do. So the return address automatically becomes call rate, or trap rate. And then you will, you know, call some functions, which will have their own local variables and return addresses, et cetera. And finally, somewhere here, you will call switch. Right? So as soon as you say call switch, the return address of the function which called switch gets pushed as the EIP. Right? So the last, next four call save registers get saved by the switch function itself. And that's it. Right? That's where you have switch. So at this point of the stack, you actually, actually perform the switch. Right? So for any runnable process, this will be basically the structure. Context will be pointing here. Everything here is completely unused. And everything here is meaningful. And when I'm going to switch, I'm going to switch to the other process's context. And I'm going to pop these values to refresh my kernel, to reload my kernel state. And then the kernel is going to do something. And then eventually, it's going to pop these values to reload the user state. Okay. Good. Right. So today, I'm going to talk about, I'm going to be going to look at how xv6 creates the first process. Right? So basically, what it's going to do is that it's going to allocate a page directory. And it's going to initialize the address space to point to some code that the kernel wants to execute first in the user mode. That's one thing it'll do. Then it will allocate a kstack. And it will organize the kstack as though the process was just switched out. Right? And then it will add the, and it will initialize the PCB to point to all these things, kstack and page directory and other things. And it will just add the PCB to the list of schedulable processes. In other words, it will just mark the PCB runnable. Right? And then it will call the scheduler. And the scheduler will just go through the list, pick up any runnable process. In this case, it is the only runnable process, because it's the first process that you're creating. And it'll just pick it up, because you had set up the stack in exactly the way any other process would have been, had it been switched out, it just starts running in the normal way. Right? Okay. So let's look at that. We're going to look at this function called userinit on sheet 22. So this function is called from main after other things have been initialized. And userinit is going to set up the first user process. Right? And what does it do? It makes a call to this function called allocproc. What is allocproc going to do? It's going to allocate a PCB. Okay? It's going to allocate a PCB, and it's going to... let's see what exactly allocproc does. It's going to allocate a PCB, and it's going to allocate the kstack of that PCB. And it's going to initialize the kstack with the trap frame, et cetera. All right? So let's look at allocproc first. So on the same page, there is allocproc, line 2205. All it does is it assumes that there is a global variable called ptable, this table of all the processes. It iterates over the table. Right? So I've been saying that it's a list of PCBs, but x36 implements it as an array of PCBs. Right? So it just says that there's a limit to the maximum number of processes you can have in the system. That's nproc. So it's just going to go over this array of processes, and if it finds that one of those processes has a state unused, then it's going to do other things. If it couldn't find anything that was unused, then it just says, I couldn't find anything. And so what should happen is basically, if the first process was not being able to get created, then you should just return an error that you couldn't boot properly, basically. If you came here because of fork, then you would just return a minus one value to the fork. Right? Okay. So at this point, you have allocated, you found a process that you found space for the process. You found space for the PCB. You initialize its state to embryo. So you initialize it. So from unused, you initialize it to embryo. The reason you initialize it to embryo is because x36 is a multiprocessor system. So once you have taken up, you have pinned one particular process block and said that I want to use it, you want to basically mark it so that nobody else starts using it after that. Right? So exactly how this works, et cetera, will be a discussion of concurrency and locking, which we're going to do next. But let's just notice this at least. Right? Okay. Then we assign a PID to this process. So there's this global variable called next PID, which is, let's say, initialized to one or two or whatever. And each time you create a process, you just increment PID and just put it in this variable. And then you release a lock. We're going to talk about locking later, but let's just not worry about it now. All right. Then we allocate a stack, kstack. Right? Once again, if you couldn't allocate a stack, you return an error, and you reset the state of the process to unused. So, you know, you didn't actually do anything, and fork failed. And then you basically initialize a stack pointer. There's a local variable, sp, to kstack plus kstack size. And in our case, kstack size is 4096. Right? And then from there, you make space for the track frame. So size of star, p point, or tf is basically saying size of type track frame. So basically say, you know, that's the location where you're going to point tf to. Right? As I told you that, you know, kstack and tf are always at a constant offset. You don't really need to store it, but it's more convenient to store it. Okay. And then what he's doing is, he's basically saying, let's push the address of this function called trap rate. Right? So we saw this function called trap rate that just pops all the registers, and then calls irate. So it just pushes the address of this trap rate function into the stack. That's what it's doing. So sp minus is equal to four, and star sp is equal to trap rate. That's just pushing trap rate into the stack. And finally, it's making space for a context structure. Right? So it just makes space for a context structure. The size of star p point or context. So let's, I'm going to show you the context structure. Context structure is nothing but those five registers, four polysave registers, and one instruction pointer, eip. Right? So all those five registers are spaces created for. And you make context point to that location. Is context also always at a constant offset from kstack? In this case, it is, right? Because you can say that context is always equal to kstack plus kstack, kstack size minus size of star tf minus four, and that's minus size of star context. And that's where context is always going to point. But in general, is context always at a constant offset from kstack? No. Right? So context may have some call chain between trap frame and actual call to switch. But in general, actually, it's a trap frame also at always at a constant offset from kstack? Not necessary, because I, the first trap frame will always be at a constant offset from the kstack. But if there was another trap while you were executing in the kernel, then that trap frame can be anywhere in the kstack. Right? So actually, you know, trap frame is not, the tf variable is not redundant. It's basically telling you the location of the last trap frame. Right? So it's not necessarily at a constant offset from kstack, it's actually, it could be somewhere in the middle. Right? So this is context. And then you, so here what he's doing is, he's zeroing out the context structure, except that the EIP of the context is set to the address of fokeret. Right? Okay, I'm going to discuss this very soon. But look at look at this first, I didn't really initialize the trap frame. Right? I did I only allocated space for the trap frame. I didn't say the trap frames register, EA should be this value, or CS should be this value or SS should be this value. They just you know, they're just random values here, I just allocated space. So this function called alloc clock is not initializing the trap frame, it's just allocating space for the trap frame. And whoever is the caller is supposed to fill values in the trap frame. So in the case of user init, we are going to manually fill some values. In the case of fork, what's going to happen? The parent process is trapped in content, I'm going to get copied into the trap frame. Right? So the alloc clock is not doing any initialization of the trap frame, it's just allocating space. And the caller, depending on whether it was a fork or whether it was a user init, is going to initialize it differently. Okay? All right. So context also has not been initialized, except there's one value in context that was initialized. That's the EIP. All other registers have been initialized to zero, which has no meaning really. Right? Let's look at context once again. This is sheet 20. So this is the declaration for struct context. And struct context has these five fields, which basically look, they're integer fields, and they have been named on the register values, or register names, EDI, ESI, EBX, EBP, and EIP. All right? Notice that these fields occur in the inverse order in which they were pushed in the switch function. All right? So, for example, you've pushed EBP first, so that comes last. In fact, you push EIP first, because as soon as you call instruction, the return address got pushed first. So EIP is last. Then you push EBP. That's second last. EBX, ESI. And the last register you pushed was EDI, so that's the first. All right? So if you look at this tag, you pushed in this order, and you pointed context here. And so context, basically, you know, if I was to get the EDI value, that's the first field of context. And if I were to get the EIP value, that's the last field of context. And so what I've done in it is basically I have set up all these four to zero, and I have set up EIP to a function called forkret. And so this is a special case where switch wasn't called by a function, but switch, right? So switch wasn't called by a function, but we just initialized it as though a switch was called by a function just before forkret, right? So that, you know, when it actually starts running, it starts running at a function called forkret. All right. So in this diagram, basically what I have done is for – so this is for a general process for any time, but for user init, for user init, what I have done is basically instead of any general EIP, I have set it up to forkret, right? And actually, there's nothing here. So this is – this is both short circuited. So the next word after forkret is trapret, if you look at how AllocProc worked. And then everything above it is trapframe, which is completely uninitialized values at this point, right? So my stack is basically this large, which has four registers, forkret, trapret, and the trapframe. That's what AllocProc does, right? This is – the same function is called even on a fork, so that's how it initializes a new process, right? So this name forkret basically means that there's a first function you should call for a process that just started after fork, right? So let's look at – let's look at the – so first, before we look at the forkret function, let's look at the user init after AllocProc, okay? So I have called AllocProc here, right? And then I set up some global variable called initProc to p. Let's ignore that for now. And then I say p – so AllocProc didn't allocate a page directory, right? The caller of the – of the AllocProc is supposed to initialize the page directory. In the case of a fork, you will just copy the page directory. In the case of user init, you are going to initialize the page directory. And the first thing you have to do is initialize the page directory such that all the kernel mappings get created. Recall that setup.kvm creates all the kernel mappings above current base. So for example, it creates mappings from zero to kernel link, and then, you know, for all the heap, and then for all the memory map devices on the top, right? So that setup.kvm, okay? And then it – so at this point, the page directory basically has all the kernel mappings, but has absolutely no mappings from zero to current base. And then there's this function called initUVM that creates mappings for the user side. And what it's going to do is it's going to create a mapping for the address is zero to something. It's zero to – actually, the first process is assumed to be less than the size of a page. So it just allocates – creates a mapping for the first page, zero to page size. And fills that location with the value of this array, you know, binary init code start and binary init code size, okay? So this array is pasted at location zero to page size, okay? So what is he going to do? He's going to paste – so the kernel already knows that this is the first process I want to run. So he's going to take that process, paste at location zero, set up EIP to point to zero, the user's EIP in the trap frame. And he's going to just leave it in the scheduler, and the scheduler is going to start running that process immediately. Okay. Yes? Okay. So what is binary init code start? Binary init code start is some global array in the kernel. It contains the – the contents of this array are basically the code in – that should be executed in user mode, okay? So once again, the binary init code start is an array, and the contents of this array is the code that should execute in user mode, right? Starting at the first location, zero is piped. And so the linker scripts have been arranged in such a way that there is some code that has been created. So what will – what the linker – what the compiler will do is it will compile this code. The code is written in an assembly, let's say. So it's going to compile that code, it's going to get some binary representation of that code. And it's going to take that code and put it in the array, binary init code start. And now this user init function is going to take contents of that array and put it at location zero till page size, and – and set up my trap frame accordingly, and that's my first process, all right? So – so let's look at the code that's going to run in the beginning, all right? So what are the contents of binary init code start? The contents of binary init code start are in this file called init.s. That's init code.s, that's on sheet 77. So that's init code.s and these are the instructions that are going to get executed when the first process actually gets to run. So all it's doing is it's – it's making a – it's pushing an argument, argv, which – and pushing – so these are global variables, argv and init, that contain the name of a file that needs to execute. And ultimately it's just making a call, system call, call sysexec. So it just calls the software interrupt and it's going to make a exec system call. So the first code is going to do nothing but just make an exec system call on this file name, called init, with the arguments called argv. And these init and argv are global variables that contain strings, which are the name of the file that needs to get executed, and argv is the name of the arguments that need to get executed. So all it's doing is making an exec system call. So the first process is going to make the exec system call, and the assumption is of course that by the time the first process gets to run, your interrupt descriptor table has been set up, so system calls can be actually executed. Make sense? So, I mean, this is just code that gets compiled by the compiler, right? But it doesn't get linked to your kernel, right? So the – the linker is going to just look at the assembly – the binary code of this particular code, and it's going to paste it in this array called binary init code start. How it happens, you know, let's just ignore that. It won't execute it. Right? So the kernel will never execute this code. The kernel looks at this code as data, that it puts into the address space of the first process. That's all. For the kernel, this code is just data. Okay, how many of you are following this, or – very few, actually, all right. Okay. Now, let's look at this again. Let's see. Okay. So, we're talking about user init that's going to create the first process, right? So what it's going to do is it's going to allocate a new PCV, it's going to initialize a new page directory, okay, and it's going to paste the contents of the first program that it wants to run into this page directory, into this address space. And that's it. Now I'm just showing you what is the code that executes in the user mode for the first process. The code that executes in the user mode for the first process is just making an exit system call. And then making an exit system call after that, I guess, right? So xv6 is a Unix-like kernel. It implements Unix system calls. We have seen Unix system calls, we have seen fork, we have seen exit, and xv6 also implements fork and exit. And so the code, the first process's code is going to use this system call called exit to start running something. And it's going to exec this program called slash init, and init is going to execute let's say the shell or something. Okay. Anyways. So it's not important to know exactly how this is being done, but let's just come back to user init, sheet 22. So let's look at what happens at this point. Let's look at what happens at this point. At this point, if I were to draw the address space of first process, okay? So I'm just creating the first process, and I'm now saying let's look at what this address space looks like. So we have seen what an address space of a process looks like. Well, it just looks like this box going from 0 to 2 to the power 32 minus 1. This is the virtual address space. And what, after setup KVM, it's kernel's virtual memory, the address space is going to look something like this. And it's going to have a mapping from current base for K code, K data, K heap, and so on, right? So that's what setup KVM is going to do. It's going to create all these mappings in the address space. So this is after setup KVM. And then there's this function called init UVM. So this is after init UVM, and init UVM basically takes arguments as an array called binary init code. Better? Oh. Okay. So after init UVM, binary init code, what's going to happen is it's going to paste binary init code here. Okay, that's what it's going to do. And the address space is going to paste binary init code here, and it's going to set up the EIP to 0. So the first instruction that gets executed is whatever there was in binary init code. And what I just showed you is that the first instruction that gets executed is just making an exec system call. So what will happen is that the controller will come here, it's going to make an exec system call, and the exec system call will proceed just like it's supposed to proceed. It's going to replace these contents with whatever is the contents of that file, load that file into these contents. Is this clearer? Just raise your hand if it's clear. Okay, good. All right. So this is binary init code. So that's what init UVM is going to do. And I just showed you the code for binary init code, which is going to, you know, exec the first process. Good. All right. So I say init UVM, that's going to create that mapping. I also, so there's a field in the struct block called size, for the size of this process. So this first process has a size of one page. That's all. So this, you know, the kernel just knows that the binary init code is less than one page. So it just creates a size of one page. So size is equal to page size. Finally it's going to start initializing the tap frame. All right. So I said the tap frame was left uninitialized by alloc proc. So in this case, we're going to start initializing the tap frame. So it first zeroes out all the contents of the tap frame. So all the registers are zero by default, except CS is pointed to the user's code segment. Right? Similarly, GS is pointed to the user's data segment. Why can't we have done, if, for example, I had done it to the kernel's code segment, then what will happen? So if I had, instead of seg u code, written seg k code, then when I would have transferred to the user, the first instruction of binary init code would have executed in kernel mode. Right? You don't want that. Right? Because those programs are going to take user input, which is untrusted, and you don't want to. So it's going to take a user program, and it's going to call exec on them and all that. So if all those things start executing in kernel mode, you're in bad shape. You want that those things should execute in user mode. And that's what, you know, you're initializing the segments to user mode so that they execute in unprivileged mode. Okay. And then you initialize other segment registers. You're just, you know, copying DS to ES and SS. E flags is initialized to FL underscore IF. What this means is that the interrupt flag is enabled in the user mode. Right? So that's what it means. And ESP is initialized to page size. What does that mean? What does that mean? ESP will, or let's say I allocated one page. This is. Page size. Right? This is page size. And the first few bytes were taken by binary unit code, and you initialize ESP here. So binary unit code needs some stack to run, and so you initialize the stack at page size. That's what he's doing. And he's just going to use two or three or four words in the stack to just call the exec system call. And it's going to initialize the EIP to zero. That's user's EIP. User's EIP and user's ESP. Right? And how is he going to do it? He's just going to change the values in the trap frame for the register's ESP and EIP. So that's what's happening. ESP is initialized to page size, and EIP is initialized to zero, beginning of initcode.s. And you set up the state to be runnable. The moment you set it to be runnable, a scheduler can pick it up and start executing it. In this case, I'm executing the first process, so there are no other CPUs, let's say, enabled. But the next thing the main is going to do is it's going to make a call to scheduler, and scheduler is going to start picking up the processes. Question? OK, so the question is, I said last time that address zero is usually unused or unmapped so that you can do this, so that malloc cannot return zero as a valid value, right? Well, I mean, actually, it's not complete. So my statement is not completely accurate. It's just that the address space is organized in a way such that malloc cannot return zero as a valid address. So in this case also, malloc will not be able to return zero as a valid address, because that zero address has a code mapped to it. Heap is not mapped to zero, right? So basically, the address zero should not be part of the heap, right? That's good enough. And in any case, this program is not going to initialize the heap or initialize malloc or free or anything of that sort, so it's OK. This is just a special program. That's just a convention for usual programs. In fact, even this function could have used malloc and free, because zero is not part of the heap. Zero is mapped. Zero is part of the code, so it can never be a part of the heap, right? OK. All right. OK, and we have the first process. So we initialize the page directory. We pasted some contents into the address space. We initialize the trap frame. We initialize the case stack. We initialize the trap frame. We initialize the context. And we have a PCB, which is full. We set its state to runnable, and that's it. And we let the system run, and the first process is going to get to run. The first process is going to call an exec that's going to, you know, execute some program. That program is going to, let's say, initialize its file descriptors and call fork, depending on what command you give on the keyboard, on the standard input. And so your first process is running after that. OK? All right. All right. So just for completeness, let's also look at other things in the process structure. So here is the process structure. We have looked at case stack. We looked at page there. We have looked at state, right? The state can be one of embryo unused. Unused basically means that this particular PCB is not being used, because it's an array. So that's how you basically check whether something is used or not. Embryo, we have seen. Runnable, we have seen. Something that's runnable. Then there's something called running. Why do I need a distinction between runnable and running? If a process is already running on some CPU, and then another process wants to schedule another process, then this process should not be a candidate. If a process is already running, then that process should not be a candidate. So one process cannot run on two CPUs simultaneously. Not allowed. So that's why you need a distinction between runnable and running. Zombie, we know what a zombie process is. Because xv6 does the same zombie semantics as Unix, so it needs zombie. So basically if a process has exited it, but a parent hasn't called wait on it, if a process is in zombie state, what do you think will happen? Page there will remain allocated or should be freed? Freed. Freed, yeah. So everything will be freed, actually. So xv6 will get freed, kstack will get freed, tf and context are meaningless. You know, just whatever is the status, exit code of that particular process, that needs to be. But I don't think even xv6 even implements exit code, so it actually doesn't need anything for that matter. I'm not sure, actually. Right. And then there's a pointer to parent, right? So that's, again, you need it for this exit wait semantics. And then there's a PID, parent, trap frame, context, we've discussed. And now let's look at channel later, field also, let's say, you know, let's look at later. This is an array of open files, strut file, star o file, number of files, maximum number of files. So this is your file descriptor table that we discussed in the first few lectures, right? So I said that every process has a file descriptor table, and a process can, you know, call open, read, write, close, dupe, all these system calls. So xv6 implements all these system calls. And this is the file descriptor table with which it implements these system calls. And it has the same semantics that's going to start from the beginning and search for the first empty file descriptor and assign it there, when you make an open call or something. Then there's a, there's a, there's a variable called current working directory, CWD. Why do I need the current working directory? Because that, the child process on a fork inherits the current working directory of the parent process. That's why when you type ls on your shell, ls knows whose contents to display, display the contents of the current working directory in which your parent was living, right? So that's a, so the, so, so CWD gets copied on fork from parent to child. And if you ever make, if you ever want to find out what, where am I, you just look at a, you just say, you know, CW, look at procs, proc.CWD. So if you, if ls wants to look at the current working directory, it can do that. All right. And then, you know, process name, that's for debugging purposes. Right? So that's basically, okay. Then let's look at the, the main function once again. Yes. Okay. Why is the type volatile? What does volatile mean? I'm going to discuss that later. Let's just, no. Let's just skip that for now. I'm going to discuss that later. What is tan? Let's discuss that later. So I haven't discussed what is tan. Okay. And this is our main function. Recall that we have, we had already seen how, you know, transfer, control transfers to main. And then this was the heap getting initialized to first, first for MB, the kernel space table getting initialized. Then everything started getting initialized. And at this point, you initialize the heap to the fizztop. And this was user in it. So as soon as you initialize the heap to fizztop, you call user in it. So the first process gets created. And after that, you call this function called MP main, the multiprocessor main, which, you know, let's say other processes are also going to call. And what multiprocessor main does is it just initializes the IDT, right? So just load the IDT into the IDTR. And then call the scheduler. So notice that, you know, in this case, the IDT was initialized after the first process was initialized. It's okay because the first process was initialized, but it will only run after the IDT can have been initialized. Right. And so IDT gets initialized, and then you call the scheduler. And the scheduler is going to go through the process table, pick up one which is runnable and call switch to it. So let's look at the scheduler. The scheduler is on sheet 24. So that's sheet 24. That's the scheduler. And scheduler is running on what stack? The scheduler is running on the same stack on which main was running. So there's just one initial stack on which the scheduler is running because you just made a function called scheduler. But what it's going to do is, it's going to, so let's ignore the locking. But it's going to go over the process table. And it's going to find if, so if it's not runnable, then you ignore it. But if it's runnable, then you fall through. And you call this function called switchUVM to P. So what is switchUVM going to do? Firstly, it's going to load the P's page table into CR3. No problem because P's page table also has mapping for this kernel. So you can just switch from, so switchUVM has changed the address space right there. So it has changed the address space. It will also set the stack, initialize the stack pointer in TSS segment. So it will also initialize the stack pointer of the new process. So it will take the ESP value of the new process and put it in the TSS segment. So that when I'm going to transfer control to this process and there was an interrupt, then the right stack gets loaded. You shouldn't load, because right now you're executing on the scheduler stack. Now you want to execute on the process stack. So it's also going to load the value into TSS so that next time there's an interrupt, it comes into that stack. Set up the state to running. And then call this function called switch that we have seen last time. The switch is going to switch from the scheduler stack to that process stack. And actually it's never going to return. It's not going to return immediately. It's going to return at the next switch. So the scheduler called switch will never return from here. It doesn't return immediately at least. The process stack has been loaded. The process stack returns. So the function that will get called after this is, in the case of first process, what's going to get called? Fork rate. Fork rate. Right? So immediately after this, fork rate gets called. You don't return here, but it's fork rate that's called and it's called on the new stack with the new stack being loaded into the TSS and with the new address space. Let's look at fork rate. 825. Well, fork rate does nothing. So this is line 2534 is where it's going to start executing. And this is just a global variable, static variable. So let's ignore this. It just releases some lock, basically. So let's ignore that also. It initializes some things and then it returns to the caller. For the first process, who is the caller of fork rate? Trap rate. Trap rate. Right? So as soon as it calls return here, it's going to get back to trap rate. Recall that the stack was set up in such a way that it looks like the trap rate called fork rate. Right? Well, you had trap rate's IEIP and then you had fork rate's EIP. So now fork rate gets to run, so fork rate could have pushed some things on stack, but it's also its responsibility to pop those things from stack, calling conventions. And then it's going to call rate, so it's going to return to trap rate. And trap rate is going to do what? It's going to pop off the trap frame and return to user mode. And trap frame was initialized by our user init function. So great. We are running our first process. Okay. So finally, let's just look at the init code function on sheet 77, which we skipped. Okay. It's time. Right. Very quickly. There's still a few minutes. So let's say it's just going to make a system call called 6exec and it's going to call actually init.c. And init.c is just going to initialize its standard output and standard error. It's also going to initialize the standard input and it's going to execute the shell. Let's initialize the standard input, standard output, and standard error. And then it starts running the shell. The shell just takes in a command and so here it's just calling 6exec sh and sh is going to take in command and start executing it. So that's how you get a shell when you run the execution. Okay. "}