{"text":"Welcome to operating systems lecture 1. This is an introductory lecture and we'll basically in this course discuss about operating systems and how they work and what are the issues when you design an operating system and implement one. So firstly, why is operating systems an interesting thing to learn, right? Well, if you look at the history of computing, most of the landmark events in the history of computing have involved operating system either at the center or as one of the components of the event. So, you know, right from 1960s till 2014, operating systems have gone through series of design changes, implementation improvements, and has always been an active area of research. So to give you a flavor, you know, in the early days of computing, an operating system used to control large machines, for example the IBM mainframes, and allowed people to run multiple processes and allow multiple users to share that large machine and get their work done. Today, operating systems are present in your personal computers, they are present in your mobile phones, they are present in your cars, and in all kinds of embedded devices, right? There are lots of different open problems that operating system researchers have to face today. For example, we are rapidly seeing rapid changes in our hardware. We are going from high-performance single-core computers to computers which have lots of cores. Already, you know, small machines like laptops have up to four cores or eight cores, and large machines, larger machines can have up to 80 or 100 cores. That's not uncommon. And so researchers are constantly asking the question, what is the right operating system for this new kind of hardware, and do our current operating systems really fit for these kind of new devices? Similarly, we are seeing, you know, advent of new kinds of devices which need operating systems, like phones. Will the operating system that runs on your desktop be the ideal operating system for your phone, or something better is needed? Then there are reliability issues. The operating system that runs inside, you know, a space mission, let's say, you know, the Mars mission or something, has to be very, very reliable, right? Definitely much more reliable than your PC desktop operating system. And so reliability is an operating system issue, and, you know, it's a constant effort of researchers to ensure that operating systems don't have bugs, or have ways to prove that operating systems don't have bugs. So all these are also research issues. Performance is definitely an operating system issue. I want to write an application, and the application is going to run on a certain set of hardware, which includes multiple, perhaps multiple processors, each having multiple CPU cores, and, you know, having memory, disk, perhaps accelerator devices like the GPGPUs, the graphic processing units, etc. And how can the operating system allow applications to use all this hardware in the most efficient way, right? And all these are basically very, very interesting software engineering, software design, and in particular operating system design problems. Okay, so let's understand what an operating system really is. So, and we're going to try to understand this by looking at the history of operating systems. So the first operating system was perhaps not designed, not very ambitious in its goals. The goal of an operating system was to allow a program to run, right? And so, in some sense, the operating system is the lowest layer of software that sits on top of hardware. And so the first operating system would just export a certain set of libraries that will allow an application to use this hardware. So the picture would perhaps look something like this. You have, let's say, if I draw the whole system as this box, and this is my hardware, then the operating system is basically a bunch of device drivers, and the application is running on top of this operating system and making calls into the operating systems to access the hardware. So the application runs on top of hardware, but for some operations, it can ask the operating system to do it. And so different applications need to be written for this operating system in this way. Notice that in this picture, I'm only drawing one application running at one time, right? So there's only one application that's running at any time on this operating system. And so this is a uniprocessor operating system, a uniprocessing operating system, right? And so only one application can run it at any time. And the operating system is just a collection of libraries, which is allowing the application to access the hardware. All right. Let's take a step back and let's also understand how a computer system should really get organized, right? So one way to organize a computer system or a software system is to just write all your software as one big program, right? So let's imagine a world where your computer, the hardware is still the same, which basically means there's a processor, there's memory, there's disk, etc. And they're all interconnected just the way they are today. But the software was indeed written in one monolithic style. So there's one large program that's going to do all your things for you, right? So for example, this program contains the logic to boot your computer from power of state to something which is usable. It contains all the logic to, you know, implement your editor, your shell, your GUI, the graphics window manager, you know, your browser, web clients, web servers, and all this. So this program could be one large program that has all these things built into it, right? And so there's this program would probably contain one large case statement, which says, you know, if the user does this, then go here. If he presses a button here, then go there. If he types this command, then go jump there, and so on, right? So you can imagine that all your software on your computer can be organized as one big program that has all these things built into it, right? It's possible. It's not very practical because completely different pieces of logic, you know, an MP3 encoder has nothing to do with a web server, have to be part of the same program, and the developers of these two different logics have to now talk to each other so that they are compatible with each other and can fit inside the same program. Also, if there's an update to one part of the program, it basically means updating the entire program, right? Moreover, you know, there are trust issues. What if I want to implement a web server, but I also know that I'm sharing this, you know, I'll be a part of this large program that also runs the MP3 encoder, but I don't trust the developer of the MP3 encoder because perhaps I don't trust his, you know, I don't trust his program because perhaps I know that his program may have bugs, or I just don't trust the developer, basically. That means that I don't trust him, and I don't want to trust him, basically. Maybe he may want to do malicious things to me. So, you know, all these things are completely not possible in this model where you have one large program. And of course, you know, it is also a software engineering nightmare because, you know, if you have one large program that's doing all these things, how is it possible to maintain this over a long period of time, right? So, you know, in theory there could be an operating system that just implements all the functionality inside it as one large program and do things, but that's not going to be very practical. So, typically what operating systems do is expose an interface, so which allow applications to run on top of the operating system, right? And these applications can be implemented independently. So, one application could be the MP3 encoder, for example, and the other application could be the web server, and these applications can run, can be implemented independently, and at one time, let's say, one application or multiple applications can run together. They all rely on the same interface that the operating system provides, and so these applications can run on this operating system as long as they obey the interface, all right? Okay, so these interfaces, in this particular picture, these interfaces happen to be the device drivers. In yet another kind of interface, you may want that, let's say, this is my hardware and this is my operating system. The operating system exposes certain interfaces and allows multiple applications to coexist at the same time. This is a multi-processing operating system. So, for example, this application could be a browser, and this particular application could be, let's say, an MP3 encoder, or any other such applications. And now, the developers of these two applications don't need to trust each other. They also don't need to coordinate with each other. As long as they meet the specification of the operating system, they can run together at the same time without having to worry about each other, right? So, this kind of an architecture is much better from a software engineering point of view. It's also much better from a security point of view, modularity, and so on. Okay, and also performance. Okay, all right. So, let's understand what kind of, what are these interfaces? You know, what should these interfaces look like? And that itself, it turns out, is a non-trivial problem, okay? So, what should the operating system interface be? And let's again face back to history. So, one of the first operating systems was Multics, that was, you know, that's coming out of Bell Labs. And one of the successors of Multics was Unix, right? So, there was a system called Unix, developed by Ken Thompson, who has won a Turing Award for his work on Unix. And other people involved in this work were Dennis Ritchie and others, right? So, what was Unix? Well, the first version of Unix, or, you know, the early versions of Unix, looked something like this. They said, okay, I want to be able to run multiple processes on my system, and what should the operating system be, provide as a minimal sort of interface? So, they started with first thinking about, you know, what, firstly, what are the hardware components? Well, the hardware components are, there's a processor, which we call the CPU, there's memory, which is RAM, right? And then there's disk. Disk has the semantics that its contents are preserved across power reboots. Also, the disk needs to be shared across multiple processes, right? So, one process may want to access file A, and another process may want to access file B. They may be running at different times, but the files A and B need to coexist on the disk. On the other hand, at that time, memory could be assumed to be, you know, exclusive. So, you could assume that if process A is running, then only process A is using the memory, and nobody else is using that memory. Notice that for the disk, that's not true, right? For the disk, if, you know, at the same time, it's important that all the contents of all the different processes, even if the process is not using them, exist. But for memory, whose contents are volatile, which means they don't persist across power reboots, it's possible for, so you can, you know, at that time, they assumed that a process basically has exclusive access to all memory, right? Of course, today, we also don't do that. We basically allow the memory to get shared across multiple processes at the same time. Let's first understand, you know, how initially the Unix interfaces look like. So, the other thing that was important was, you know, one important program that was needed was an interactive shell, right? What is an interactive shell? An interactive shell will give you a command prompt. You will type in your command, and depending on the command, some program will get to run, right? When that program finishes, you will come back to the interactive shell. And this loop, and this mechanism will continue forever, right? That is the minimum that a usable computer system should have, okay? So, there are a couple of things that are most very important. Firstly, there should have been a file system, right? So, you know, the early developers of Unix said, okay, there needs to be a file system. A file system is an on-disk data structure, and some kind of interface to access this on-disk data structure, right? So, let's say, let me draw this disk, and, you know, this disk has some contents, and a process that runs should be able to, so there's an operating system that sits between the application and the disk, and the application is going to make some requests to the operating system, and the operating system is going to translate those requests to disk requests, and then serve the application using those requests. And this translation layer was also called the file system, okay? And so, it's clear that, you know, any operating system needs to have a file system, okay? So, well, the file system in early Unix looked quite similar to what we have today, which basically means that files, there was a notion of files, which were nothing but streams of characters, all right? And there were notion of file names. And a process could say, I want to access file name A at offset B, and so the operating system will translate the file name into a disk offset, and add offset B to it, and give you the contents of that particular file. Also, you know, for better manageability, the earlier file system also had the notion of directories. It basically meant that the file, the file name, the file system, or the namespace of the data structure, was organized in hierarchical manner. It basically means that file names were, basically, had a full path name associated with it. It basically meant, where do you go from, and so on, which included starting from the immediate parent directory, to its parent, to its parent, till you reach the root, and so on. That's one thing that that Unix had to have. And the way they did this was basically using an interface which said, you open a file, which basically means that, you know, I can say, I want to open a file foo, then I basically can now use, so open, when I open a file, I could, let's say, open a file name, and this would give me what is called a handle, or a file descriptor, which I'm calling FD. Then I could read on the file descriptor. I could say, I want to read in this file, and, you know, I want to read from this file, which I have opened previously, into a character array buff, 100 bytes, let's say. That basically means that I'm going to read 100 bytes from this file, and store those contents into buff. So, or I could say, I want to write to this file 100 characters from, from buff, right? So, read basically says, read from file, and put it into this character array, and write means, read from this character array, and write to this file. By the way, what is buff? Buff is a pointer in memory. If I look at it again, my hardware looks something like this. I have a CPU, on which my instructions run, memory, and disk. So, the CPU is going to run this instruction, which will basically implement, which will basically make this system, which will call this function called read. Buff will be somewhere here, and it'll have, let's say, a hundred characters in it, and the file foo will be somewhere here, and CPU could execute this command called read or write to transfer contents from memory to disk, and from disk to memory, using these read and write commands. Notice that the application does not need to worry about, you know, which disk it is, or how do I access the disk, etc. All those things are abstracted away from, by the operating system. The operating system knows what disk it is, you know, how to, how to run that disk, how to write to that disk, etc. And the, and the interface that the operating system provided, or the unit provided, was this read and write calls that the application could make to read or write from the disk, right? That's one thing. The other abstraction that they had was that of a shell. So, they said, okay, because the shell, or the interactive shell, has to be such an important part of the operating system, the shell was implemented inside the kernel, okay? So, let's say this is the operating system, OS, and I'm going to, the operating system is also often called the operating system kernel. So, I'm going to use the word kernel and operating system interchangeably. And, and let's say this is the hardware, once again. And one part of the operating system would implement a program called shell. And let's see what the shell does. The shell basically gives you a command prompt. Let's say the command prompt is $, and then you type a command. Let's say you type a command, browser. What the shell is going to do, is it's going to check, treat this command as a file name. It's going to search for this file name in the current directory where the shell is running. And if it finds the file name, then it is going to treat that file as an executable program, and we're going to run it, okay? So, let's say browser was a file that existed in the current directory on, in which the shell is running. Then, that file will get loaded as an application, and control will get transferred to the browser, okay? So, notice that basically the operating system is being, is basically providing interfaces for you to run different programs, and allowing different programs to coexist simultaneously on the disk, right? At this point, we are assuming that only one program is present in memory at any time, right? So, and there's a special program called shell inside the operating system, or the operating system kernel. And this shell is going to take a command from the user, which basically means it's going to read from the, from some port, let's say the keyboard. It's going to read from the keyboard, interpret that command, which basically means it's going to, typically it will interpret the command as a file name. It searches for the file name in the disk, in the file system, really, right? And if it finds a file with that name, then it loads that file name, so that file basically should contain some data, some instructions that need to get executed. So, those instructions get loaded into memory, and control is transferred to that particular file, program. That program is now going to run all by itself, right? So, it's as though nothing else is present in memory, it's just that program that's present, and so that program is going to run all by itself. And when it's running, it may make more open calls to open more files, it may make more read calls, or write calls, to, you know, to read or write files, and at some point, it may want to say, I'm done, I want to exit, right? So, what was, how was exit implemented in Unix, right? So, there needs to be something called exit in early Unix. How do you exit? Well, at that time, so in the early version of Unix, exit was basically implemented by just returning back to the shell. So, if, so there was another function that the operating system kernel provided, which was exit, and what that will do is it will remove this from memory, and jump back to the shell to take the next command, right? So, you have to print the next dollar sign, and here you are, and you can now print your next command. There were other things that the operating system had to be careful about. Firstly, if the browser had opened certain files, then when you could return back to the shell, the first thing the shell would do is close all the open files, so that if the new program gets to run, he can open more files, and so on, right? So, this was the simplistic model of the Unix operating system in its early days, and basically, what we have seen is there are few fun things that the operating system was providing us. Number one, it allowed it, allowed us to start a new program, start slash load a new program, and this, it was being done using the special program called shell inside the operating system. It allowed us to open, read, and write files, and it allows us to exit. So, some functionality was that applications use. Examples. These are example functionalities that the application is using, and you've seen how they're using it. All right, so notice that in doing this, in doing this operating system design, the designer has just basically carefully decided that some part of some functionality needs to be part of the operating system kernel. For example, the shell program is part of the operating system kernel, and the device drivers are part of the operating system kernel, and some part of the logic does not need to be part of the operating system kernel, and it should be present as application logic in executable files that can be executed by the user as well. Then, very soon, people realized that, you know, even the shell does not need to be part of the operating system kernel. One of the important things that go into an operating system design is to make the interface as small as possible, and as usable as possible, and yet as powerful. So, today, the operating system kernel does not provide the shell command. Instead, the shell itself runs as a separate application, right, and the shell has ways to tell the operating system to start another application. So, for example, the shell could tell the operating system to suspend itself and start a browser, just like before, except that this time the shell is not part of the operating system. The shell itself is running as an application, and in order to do that, it's important that you have interfaces that allow an application to be able to create another application and jump to it, okay? Right, so these functions that the operating system provides, these are, you know, these functions basically form the interface of the operating system, and let's call these the kernel functions, are called system calls. There are special names to these particular functions that the operating system kernel provides to applications to be able to do things that it wants, right? And some examples of system calls are calls to allow you to start a new program, or to read or write to a file on the disk, or to exit, right? And there are more system calls that we're going to look at as we study this course further. Okay, so let's continue with this particular model where we said that the shell itself is written as an application, and the operating system provides certain interfaces to allow the shell to start another program, okay? So what are these interfaces? So Unix provides a system call called fork, and another system call called exec. So, and these system calls are used to start a new program. Let's see how fork and exec are used. So first let's talk about exec. So let's say I am an operating system, and an application is running here. Let's say it's a shell. The shell can make a system call called exec. So exec takes an argument which says file name, and what happens if a program calls, exec system calls, is that firstly the operating system will search for that file name in the file system. So it searches for the file name in the file system to find, you know, in the current directory to find if there's a file with that file name. If it is there, and it is executable, then it replaces the shell with that particular file name. So let's say the file name was browser, then the shell will get replaced with browser. So exec is a way for one program to load another executable from the disk, right? And it's done using the file name. So there's a file name that the program gives that says I want to run this particular program, but the problem is that once you do that, you yourself are no longer there. So at the point when you call the exec system call, you are the one who is occupying memory. As soon as you call exec, the operating system removes you from the memory and instead loads the contents of that executable into memory and transfers control to it, right? So essentially that means that if a shell program ever calls exec, then the shell program will never get to run again, right? It will be the new program that will run. And when that program calls exec, it's no longer the case that the transfer, the control will get transferred back to the shell, unlike in the original Unix, right? Because in the original Unix, the shell was part of the operating system kernel, and so it was possible to jump back to it. But here, because the shell was an application, and the application has called exec, so it has completely removed itself from the picture, right? And all its state has been wiped out, and so there's no way that operating system can jump back to the old program. Notice that operating system doesn't even know that this particular program is a special program called shell, right? It's just one of the different programs, and it doesn't know what point it was in when the exec system call was called, so it has no way of reconstructing that program back again. Exec is one way to load another program, but it also means that, you know, I completely get washed out, and there's no way that I can return control to myself later on. That's not good enough for us to implement the functionality of shell as we know it, right? Because the shell, as we know it, basically allows us to type a command, the command gets executed, and when the command exits, the shell can run back again, right? So that's something that we want, and exec is not going to do the last part, which is return back to the shell. So the other system called fork can perhaps help, so let's see what fork is doing, right? So what is fork? Well, fork, basically, let's say there's a program called L that's running. It calls a system call called fork. What happens is, when it calls a system call called fork, two different apps get created simultaneously, identical to each other. It's like, you know, a parent, so one child, one process creates an identical replica of itself using fork, right? So the two shells that get created, and at any time only one shell can run, so what the fork system call is going to do is it's going to create two copies of itself with identical state, right? And identical state and identical value of the program counter, so they're going to both be executing the same next instruction when they call fork. Of course, in our model we are saying that only one program can run at any time, so what will happen is one of them, let's say, so firstly one of them is called the parent, the one who called fork, and the other one is called the child, right? The program that called fork is called the parent, and the program that just got created, or the process that just got created is called the child. So a little bit of terminology here. There's a program which exists as an executable on disk, and there's a process which is a running program. The exit system call takes a program and converts it into a process, a running program. The process runs and you know it changes its own state, so process has its own state in memory, and as it runs it changes its own state, and at some point it calls exit, let's say. So initially the shell was running as a process. The shell made the fork system call, and it created two processes, the parent process and the child process. Now at any time only one process can be active, let's say, and if it's a uniprocessing system, then let's say the child process gets stored to disk, and this is the parent process gets stored to disk, and the child process gets to run, and so that's the semantics of fork, but our real goal was to be able to implement the shell functionality. So what can be done is that the parent process creates a child process, and the child process now calls exit. What happens is the parent process still exists exactly at the point where it had forked a new process. The child process can now load the new program, which basically means the shell gets wiped out, and instead gets replaced by the browser. The browser can get to run, and at some point the browser will call exit, in which case the whole process will get wiped out. So we've seen that there's a system call called fork that allows you to create a new process, which is a replica of the process that called fork, and there's a system call called exit that allows you to stop the current process or completely free the current process, and there's a system call called exec, which allows you to replace the contents of the current process with a new program. Now using these two system calls, fork and exec, it's now possible to implement a shell-like program as an application. So for example, a shell will first call fork, so it will create two copies of the shell. The child copy of the shell will call exec on the command that you gave on the command prompt. The command will get to run. When the command finishes, it's going to call exit, so that process gets wiped out. The old shell, the parent shell that was stored on disk, gets loaded into memory and continues from where it left off, right? So that's, you know, that's one way that you can implement the shell functionality. So as opposed to having the shell as part of the operating system kernel, it is a much more modular way to actually have the shell also as a separate program, much more powerful way, in fact, to have the shell as an other application and have these special system calls called fork and exec that allow you to implement the same functionality as the shell. In fact, the system calls fork and exec can be used by any application, right? The shell is just one of the applications and the kernel doesn't even know that this is a shell, right? It can be just any other application. So any application, when it calls fork, creates replica processes of the parent process and any process that calls exec is going to load the file into the current process. There are a few things that I have skimmed over. One is when a fork system call is called, then there are two processes that return from the fork system call. So fork is a system call that is called by one process but returns in two processes, right? So one process calls fork and two processes return from fork at exactly the same program counter, right? But there was a difference. I said the child will execute the exec system call next, if it wanted to implement the shell functionality, while the parent will just print the next command prompt. So how do you do this? Because the two programs are completely identical, they are twins, how do you decide whether I am the child and I should call exec or whether I'm the parent and I should actually display the command prompt? So the fork system call has a return value. So the syntax of the fork system call is, fork returns a return value which I call the PID or process ID and the return values are different in the parent and the child, okay? So let me just draw this as a picture. So let's say this is process, so firstly every process has an ID. So let's say this is process 10, which basically means each process has an ID. So this process has an ID of 10, so PID is equal to 10. This process makes a system call called fork and the operating system returns from this system call. But it returns in two places. So it creates another process, let's say it creates another process, another child and this child has a PID of 20. PIDs are assigned by the operating system, so it can choose any way of assigning operating system. And this one also returns, behaves as if it has just returned from fork. This particular process didn't ever call fork, but it behaves as though it has just returned from fork. Both of them are going to return at exactly the same program counter, except that the return value in the parent will be different from the return value in the child, okay? So in the parent, the return value is the PID of the child. So the return value in this case will be 20, right? So fork return value, let me just write this, is PID of child. So there are two return values. One is for the parent. In the parent process, the return value is PID of child and in the child process, it is some number which cannot be a PID, let's say 0. So here the return value is 0. So all that you need to do, all that a programmer needs to do, is to check the return value. If the return value is 0, then I will call exec. If the return value is non-zero, then I'll print the next command prompt, for example, right? So let me just write this more formally. I'm going to write the shell program, very basic. It looks something like this. An infinite loop just continues till the user types exit or you know just some something else to basically stop it, but otherwise it just keeps running and it has some function to read command. How it reads the command, let's just abstract it out. Let's say there's some function which says read command. You know it's going to make some system calls internally to basically read the command. This read command is not a system call. I'm just using this function as a placeholder to say, you know, it will call other calls that we'll discuss later and it will say PID is equal to fork. This is a system call. System call. Then I'm going to check if PID is equal to zero. Then exec, whatever you read from here. Else, let's say, you know, else you just read the next command. What's happening? Here's the program that will, you know, at a very basic level implement the shell functionality. It reads the command, calls fork. In the child process, it calls exec and in the parent process, it just reads the next command. So this will exactly do what we wanted it to do basically, which means it will execute the new program and allow the previous program to do this, to repeat the same thing again, but the previous program will probably get to run only after when the new program has finished, for example. So this is a uniprocessor sort of uniprocessing environment where only one process gets to run and let's assume that the child process gets to run first. So the child process is going to run and when it calls exec, then it's going to go away and the parent process is going to get to run now and the parent process is going to go back in the loop and read the next command, right, happening in this loop. So there are many details, many things that I have omitted here, but it's important that before we go there, you understand the functionality of fork and exec and the use of fork and exec. Now let's understand how you read the command, right? So typically we think of read command as something which is being read from the keyboard, right? So the user is typing some command, he presses enter, that's a command. So how do you allow an application to read the keys being pressed on the keyboard, right? Similarly, how do you allow an application to be able to write characters on the console, right? So both these things are mediated by the operating system and in general, any resource that is a shared resource which needs to be shared across multiple applications is usually mediated by the operating system kernel, right? Because if anything is shared, then the operating system needs to make sure that there are no concurrent accesses by multiple applications that are, you know, different applications are not stepping on each other's toes, for example, right? The operating system needs to mediate in the middle. Some examples are, we just saw that the file system is a way for the operating system to allow mediation of the disk blocks, right? So the file system is basically an on-disk data structure that's shared by multiple processes and the operating system basically exposes functionality, like open read write, to allow applications to access these disk blocks which are shared. Similarly, the keyboard and the console, in fact, the other hardware devices are shared resources and different processes may need to access these shared resources and once again, all these hardware devices, the access to these hardware devices is mediated by the operating system. One contribution of the Unix system was this was a general interface to be able to mediate, to be able to use across a variety of devices and other shared resources and this interface is open, read, write, and close. So I can say open a resource which and I name the resource using a name and it will return a file descriptor. So we've seen this before, right? But we were seeing this in the context of files only, but the same thing can be applied to other things like devices, like the keyboard and the console, and how we're going to see this. So when an application says open, that's the time when the operating system is going to check whether, let's say, somebody else is using that resource. If so, perhaps the operating system may want to say, no, I will not allow you to open it, in which case the open can return an error, right? So typically, you know, the system calls return positive values and if they return a negative value like minus one, it indicates that the system call failed. So if an application calls an open system call and it gets a minus one return value, it basically means that the device was not, the file or the device was not open. Once you open, if, let's say, you opened a file name and a file descriptor was returned, which was a non-negative value, then that file descriptor can be used to, as an argument, to future calls which are read, no, read buff size, write, read and write to that resource. Once again, then the operating system can decide whether it allows read on this particular file descriptor or not. So, for example, if I try to read from the console, you know, I should get an error. So, you know, it has a return value which can be, which can be negative, which basically means that your read was illegal. So I shouldn't be allowed to read from something which is an output device or output file. Similarly, I, you know, I shouldn't be able to write to, let's say, the keyboard or to a file which is a read-only file and so on. So the nice thing is, because of the center phase, the operating system gets to also in check or do, perform access control for the applications to the shared resources. And then, finally, you could do close file descriptor to close that particular file. It basically means that I'm done with this particular file and other people can, let's say, use it, etc. So it allows the operating system to know who has which files open. Okay, so let me take this a little further. So how is the file descriptor returned? It turns out there's also a way, there's also a convention in which these file descriptor numbers are returned. So whenever a file, a process called open, a certain file descriptor number will get returned and let's understand what this convention is. So we said there's a notion of a process, right? A process is a running program. So let's say I'm drawing a process as this rectangle and there's a program that's running inside it. Let's say the program is browser. Each process also has certain state called the file descriptor table and this file descriptor table is hidden from the program. I mean the program cannot access it directly but the program can manipulate it using open and close calls. So when a program calls open, the operating system searches for the first available file descriptor and so let's say I say open foo. I search starting from the beginning. So the file descriptor table has key value pairs. The keys are numbers starting from 0 till some maximum value, right? And the values are structures which contain whether it is opened or not, whether and whether and if it is open, what are its, where it's personal equations. For example, you know 0 could be pointing somewhere, 1 could be pointing somewhere else, 2 could be pointing yet somewhere else and 3 may be empty. So when I say open foo, what will happen is the operating system will go through the file descriptor table, look for the first unused FD which is 3 and it's going to put foo here and return 3. That will be the return value to the application. The application can then use read write close on this file descriptor to read or write to this file as we solve. The first three file descriptors 0, 1 and 2 are special. They are called standard input or STD in, standard output, that's 0. 1 is standard output, STD out and 2 is standard error. The process has three special file descriptors 0, 1 and 2 which are, which refer to a standard input or their special name for these three file descriptors and the names are standard input, standard output and standard error. The idea is that a program typically will read from a standard input and write to its standard output and if there is an error, it will write to the standard error code, okay. So if I am a shell program, then I will always read from my standard input and write to my standard output. I don't care whether the standard input is the keyboard or something else. I don't even care whether the standard output is the console or something else. The program is, the semantics of the program are that it reads from the standard input and writes to the standard output and somebody else, let's say the operating system, is responsible for deciding what is the standard input for this program and what is the standard output for this program, right. So let's assume that the standard input, so let's assume that the standard input, the 0 or standard input, is pointing to the keyboard and standard output points to the console and standard error also points to the console. So now if the program calls write on file descriptor 1, hello 5 basically says I want to write, print this buffer which has 5 characters in it, then that program is effectively writing the string hello on the console. If the program says read from standard input some characters into a character adeba which he may have declared of some size, let's say 100, then it will read a maximum of 100 characters but if the user enters before the 100 characters, that's also fine. So it's going to read some set of characters from the keyboard to this buffer, right. So that's the way you read or write to or from the console or the keyboard. And notice that very elegantly and very smartly the operating system designer has used the open read-write closed system calls to also be able to read or write to the devices and not just to the files. Okay, we're going to continue this discussion in next lecture and yeah that's it for today. Thanks."}