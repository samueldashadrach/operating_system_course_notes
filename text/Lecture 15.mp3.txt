{"text":"Okay, welcome to Operating Systems Lecture 15. So let's review the virtual memory subsystem as we have been looking at it. So when you boot up the machine, we said that we start in the physical address space, right? And so if you use address x, then it just, if x is less than m, then you hit the physical memory at that address x, right? You straight away hit the physical memory. There's no translation involved. If you hit, if you try to hit a physical memory address that's greater than the available memory, let's say capital M is the amount of physical memory available in your system, then it will throw in an error. So that's not valid, right? So at boot up, you have this simple system where there's no, there's almost no virtual memory subsystem, and it's completely flat from zero to M. Of course, recall that we boot in 16-bit mode, so segmentation works in its primitive form where you can add the segment register after multiplying it by 16 and all that. But for all practical purposes, you know, our kernel that we are studying sets all segment registers to zero, so you have a flat address space from zero to M. Then as soon as you enable segmentation in 32-bit mode, so you switch to, you enable segmentation, you initialize a global descriptor table, and you switch to 32-bit mode. The moment you do that, you, all your addresses are now getting translated through the segment hardware, right? Each instruction has a default segment, right? So for example, if you are just making an access through some register, then it will, the default segment is DS, right? The instruction itself, EIP, the instruction pointer, itself always goes through CS and all that. So, in theory, you could enable segmentation and you could use segmentation to segment your address space, but in the kernel that we are studying, it just sets base and limit to zero, base to zero and limit to 2 to the power 32 minus 1, so once again, I have a completely flat address space, right? So if you say I want to access address X, so let's say you fill in the value X into your EIP register, it just goes into the physical memory at address X, and as long as it's between zero and M, you'll see a valid byte, if it's greater than M, you'll see an error, right? Some kind of an exception will be thrown by the hardware. Similarly, ESP or any direct addressing, these addresses can be generated in many ways, through a register, through direct addressing, through displaced addressing, right? All those things we have studied already, right? In any case, they all go through segmentation, and we saw that after enabling segmentation, our address space is still the same, zero to M, okay? So here's another figure, so after enabling segmentation, I had zero to M. Now, the boot sector operates in this mode, where only segmentation is enabled, in 32-bit mode, and in that mode, the boot sector was living in the first 512 bytes of the disk, so the boot sector has code to load the kernel. The kernel lives from the sector number one to some value, and whatever that value is known to the boot sector, the size of the kernel is known to the boot sector, and the boot sector loads that many sectors from the disk, and puts them in memory. While it's doing that, the address space is still zero to M, right? So it picks up that kernel, and sticks it somewhere here, in this area, right? We saw last time that it sticks the kernel at, starting at address one MB, right? So it starts spacing the kernel starting at one MB, and from there on, it spaces the kernel, and recall that the size of the kernel wasn't very big, either, the size of the kernel was, if I remember correctly, definitely less than one MB, right? So you start the kernel from one MB, you stick the kernel from the disk, stick it at physical address one MB, and it will, you know, at most, go to two MB, right? All the kernel code, and the kernel data. Also recall that the kernel itself has been compiled with virtual addresses, so all the symbols inside the kernel image have virtual addresses associated with them. So if I say I want to branch to main, the address of main will be a virtual address, right? It will be a virtual address in the sense that it will be an address above this value, eight and seven zeros, which is also called kernel base, in our code, it's called the kernel base, right? So all the symbols in our image have addresses above kernel base, or above two GB, so all the symbols in that have addresses above two GB, so any time I dereference a symbol within my kernel code, I'm going to be trying to access a region above two GB. But in this address space, it's not possible, right? Because assuming M is less than two GB, if I try to dereference a symbol in the kernel image, I'll see an error, I'll see an exception, right? So not possible at this point. So the boot sector, so what the boot sector does is it loads the kernel, and it jumps to the first instruction of the kernel, and recall that the kernel was stored in ELF format, so the boot sector knows exactly where to start, and so the kernel, the first instruction of the kernel gets started, and the first instruction of the kernel lives in this file called entry.s, right? Now the first few instructions of the kernel, entry.s, are going to execute in this address space. So these instructions have to be very careful, they shouldn't be dereferencing any kernel symbol, because all kernel symbols have addresses above two GB, right? The moment it dereferences a kernel symbol, I'll get an exception. It's not legal in this address space, right? The first thing it does, the entry.s file does, is it changes this address space by enabling paging, right? So it enables paging, and it uses a page directory called entry page directory, right? And we saw last time that this entry page directory implements an address space, where the first four MB are mapped identically. So if you access an address x within zero to four MB, you will hit physical memory at address x, right? On the other hand, it also maps this address kern-base to kern-base plus four MB to the same location, zero to four MB, right? So if you access address kern-base plus x, and assuming x is less than four MB, then you will hit physical address x, right? So that's how the entry page there was configured. And so the entry.s code just switches from this address space to this address space as soon as it enables paging, and sets up cr3 to point to entry page there, right? So it points cr3 to entry page there, enables paging, and suddenly I'm running in this address space. Recall that because the kernel itself, all the instructions, the entry.s file itself, was living in less than four MB space, so we said from one MB to two MB, let's say, all the addresses, you know, the EIP and ESP still remain valid, because the addresses from here are identical here, zero to four MB, right? So those remain valid. You don't know, it's not like, you know, I'm standing on the ground and the ground has been taken away from me, it's not true, because as long as the kernel is less than four MB, the kernel is safely mapped, right, so the next instruction can execute, right? So you enable paging, but you ensure that the ground that I'm standing on still stays as soon as I switch the address space, right? But in this new table, there is an extra mapping, and this table is going to be used to switch from here to here, right? Recall that all the symbols in the kernel have values which are in this range, so I shouldn't be dereferencing any symbols from here. The only thing I want to do is I'm going to look, so in this, there are some symbols like there's a region that's allocated as stack, right? So we saw, so let's look at the entry.s file, okay, sheet 10, and if we see, there is this function which is loading this value stack plus kstack size into ASP, kstack size is a constant, stack is a symbol that has been declared here, right? So stack is a symbol in the kernel, and recall I'm saying that all symbols in the kernel have been compiled to have addresses in the kernel's virtual address space, which is above current base, right? So the stack, the value of stack will be some, you know, current base plus something, something above current base, and so that plus kstack size, kstack size is let's say, you know, 4096 bytes, so that variable is loaded into ASP. Recall that at this point the paging has already been enabled, so this address should be a valid address. I should be able to dereference ASP because I'm operating in this address space, right? In this address space, ASP will be pointing somewhere here, and so when I dereference it, I'll get the right value. So I was able, so notice that the deref, I only started reading the kernel symbols after I enabled paging. Before I enabled paging, this code did not read any kernel symbols, except that one kernel symbol that was read was entry page there, but it was converted to its physical address before it was loaded into CR3. In any case, CR3 is going to take a physical address, so it's okay. A physical address is already mapped, right? So this piece of code in entry.s is very carefully written. There's some amount of tricks involved in this kind of code, and this kind of tricks you can only see if you are actually looking at some kind of, you know, real code, right? So it, you know, if you find this interesting, you should probably go and single step and see exactly what's happening, you know, as soon as you turn on paging, what addresses become valid, what remain invalid, what were valid earlier and have become invalid now, what were invalid earlier have become invalid now, et cetera, et cetera, right? So it's interesting, okay. And then you basically, so at this point, though, you don't need to do any convergence from V2P, right, because stack having an address above 2 GB is a valid address. You are already in the new address space. Similarly, main is a kernel symbol, which will also have an address which is above currentbase. And what you're going to do is you're going to move, jump to main, right? And the moment you do that, you have reloaded your EIP with a kernel virtual address, which is above currentbase. So you loaded ESP with a kernel virtual address here, appropriately, and here you're going to load the EIP with a kernel virtual address, okay? So at this point, so so far, my EIP and ESP were pointing somewhere here, as we reloaded ESP to point here, and it's standing on solid ground. And then I jump to main, and once again, EIP now points here. So now both my ESP and EIP point here. And from now on, I'll basically be executing in this space completely, because I've forgotten about all my addresses here. Anything I dereference from the kernel will have addresses in this space. So from now on, I just execute in this space, right? From now on, it's just normal plain C code that can execute. You know, just plain dereferencing should work, right? But this kind of tricky code had to be written in assembly because, you know, C doesn't understand these different address spaces and all that kind of stuff. It's very tricky. And I have carefully done this, very carefully done this, okay? All right, so and so we said, okay, let's look at, so now we're going to jump to main. And here's the code for main, right? And main is this long function that, you know, that we don't necessarily need to go into full detail of. But the important thing to note is that this is the first instruction that will get executed. And at this point, the stack has been initialized correctly, right? With some size, stack size, k-stack size. As long as these functions don't overflow the stack, right, don't use too much stack space. For example, they don't, the function called depth is not very large, never. They don't allocate local variables that are too large or too many local variables. So that stack should be sufficient to implement all these, to execute all these functions, okay? All right, so the first function it calls is k-init1. And so this is a physical page allocator, all right? So it's going to initialize functions called k-alloc and k-free that allow you to take physical pages from the available address space. We're going to study this later, but let us assume that this function works correctly. And after this function has executed completely, the kernel can make calls to k-alloc and k-free, right? k-alloc is just like malloc for kernel. So just, you can allocate memory and you can free memory, except that k-alloc only works at page granularity. So malloc can take any size, but k-alloc can only, one k-alloc call will allocate one page and give it to you, okay? And then there is this function called kvmalloc, which will initialize the kernel page table, and that's what I'm going to discuss today, all right? So we said that this is the page table after entry page there. And what the kernel wants to do is that it wants to remove this space and map this space completely into physical address space. So right now, only the 0 to 4 MB region is mapped. You want to map entire 0 to M in this area, right? Then you want to remove this so that this can be used for user pages, right? Recall that was what the xv6 paging configuration was, okay? So in this kernel page there, so let me call it k-page there, I want to switch from this address space to this address space. And so what I'm going to do is I'm going to map, right now it says 2 GB plus 4 MB, I'm going to map the entire physical memory from here, right? So I'm going to say 2 GB plus M, right? And this is entirely going to go to 0 to M in physical memory, right? That's what I want, and how I'm going to do it, we're going to look at the code later. But let's just see what we want, right? We want to map the entire physical memory here. Also recall that the first 1 MB was reserved for memory map devices, right? The first 1 MB of physical memory address space is actually not memory, it's console and other things. So even that gets mapped, but that's just reserved for the memory map devices, right? Also recall that I loaded the kernel at 1 MB. So this is, let's say, M map, let's say M map D, memory map devices. Then there is some area which will be loaded for the kernel. Recall that we had loaded the kernel starting at 1 MB of the physical address space. So starting at 1 MB, you're going to have the kernel, both code and data, right? And then all the other space, I'm going to call it free space, right? And that's the space I'm going to manage using kalloc and kfree. So that's the space I'll say, okay, this is space that you can use for your heap, right? Or this is a vacant space, and this is a space that you can allocate for your data structures like the page directory, right? So where is the page directory going to get allocated? Recall that the entry page directory was a global variable, and so that was allocated in the data section of kernel. But anything other than that, for example, per process page directory, right? So all these things are going to be allocated from this extra space, which is wherever the kernel ends, and from there on till whatever capital M is, physical size of physical memory. Also this is a place where you're going to allocate memory for data structures like process control blocks, right? And most importantly, this is a space from where you're going to allocate memory for the user processes themselves, right? So what you're going to do is you're going to say kalloc, you're going to get some page, and you're going to create a mapping in this area for that. So recall that's how it works. You basically allocate some page here. Let's say a user says I want more page, or a user says I want to load a particular executable, and that executable is larger than the current allocation of the process. What it's going to do is it's going to create mappings here. It's going to allocate some space from here. Whatever space it allocates from here, it will have some backup in physical memory, right? Some pointer into the physical memory. Whatever pointer I get from allocation here, I'm going to convert it into its corresponding physical address, and then create a mapping from here to that physical address, right? Recall that the entire memory has been mapped here. The entire memory has been mapped in my virtual address space. I allocate some area from that virtual address space. I get a page. I convert the address that I got to its physical address, and then I create a mapping in the user side of things to point to that, right? So these pages which are mapped in the user side actually have two mappings in the page table. One on the kernel side, and one on the user side, right? So the two names are the same physical location. One name will be current base plus something, and the other name will be whatever the user wanted to allocate it, wherever it wanted to allocate it, okay? All right, so, okay, so I want to switch from this organization to this organization. Also, I'll point out that the top, there's a slice of virtual address space on the top that starts at 0xFE and six zeros, till 0xFF, right? This slice of address space is actually used for memory map devices also. So just like this area is used for memory map devices, this area is also used for memory map devices. And so this map identically to the physical address space, FE, same thing, right? So basically, the physical address space, on a 32-bit x86 machine, the physical address 0xFE and six zeros is not actually pointing to memory. It's pointing to some memory map devices. And the kernel wants to retain that access, so what it does is it just says the top virtual address space maps identically to its corresponding physical address space, so if the kernel ever wants to access those devices, it can just access it using that address, the same address, right? So basically, I'm not going to use this top address space from FE0000 to FFFFF for anything other than memory map devices, right? They map identically to physical address space, right? So just to make this discussion more complete, at boot up, the address space wasn't just this, right? Basically at boot up, the address space was 0 to 1 MB is devices, 1 MB to M is whatever your physical memory is, and also there's some chunk on the top, FE to FF. This area, it can also be accessed, however, this will also point to devices, right, in the physical address space. So that was the original physical address space, so the amount of physical memory that you can have in your system is not really 2 to the power 32 minus 1, it's 2 to the power 32 minus 1, minus 1 MB, minus whatever this is, okay? And so what the kernel wants to do is retain this access, and so it's going to map this identically to the corresponding physical address space, right, that's all. Anyways, that's not really important, but when you're looking at code, it will help us in understanding what's going on, okay? So let's look at what is KVMalloc doing on Sheet17. So basically at the highest level, KVMalloc is going to initialize a new page table, which is going to have this kind of mapping, right, and it's going to switch to it, and it's going to forget about the old page table, and that's it, right? So the KVMalloc function is just two lines. It calls a function called setupKDM, this is going to initialize a new page there, KPageDir, which will have this address space mapping, and it's going to return a pointer, KPageDir, to that particular page directory, okay? So it's going to initialize a page directory. Where is it going to get the pages for this page directory? From its heap, right, from all this area that we discussed, this extra area, this is the kernel's heap. So it's going to allocate a page directory from here, and it's going to initialize it, and it's going to return a pointer to the page directory, okay? That return pointer will be a virtual address in the kernel space, right, because everything in the kernel from now on is in the virtual address. When you allocate a page, the return value that you get is also a virtual address. So if you want to convert it to a physical address, you need to subtract current base from it, 2 GB from it, right? So this function is going to allocate a page table and return a pointer to it, this pointer is going to be a virtual address, and then I'm going to call switch KVM. So KPageDir happens to be a global variable, okay, and so you just set up KPageDir to this, and switch KVM is just going to load CR3 with KPageDir, except that it's going to call V2P on KPageDir before it loads it in CR3, okay? You allocated KPageDir in your virtual address space, initialize it, you got a virtual pointer, you convert it into a physical pointer and load it into CR3, recall that CR3 takes only physical pointers, okay? So that's very simple. What we're going to look at next is set up KVM, how exactly this page table is getting initialized, all right? So what is the structure of this page table, okay? So on the same page at line 1737, here is the code for set up KVM, and what it's doing is it first calls KAlloc function to get a page from the kernel heap, right? So let's just assume that KAlloc just allocates a page from the kernel heap and returns a pointer to it, just like malloc, and puts it into PageDir. Just in case the malloc fails, or KAlloc fails, then it just says, oh, I can't proceed, it returns zero, and ultimately it will return zero and tell the user that, you know, something has failed. Why could KAlloc fail? Give me some reasons. You have run out of memory. So let's say the physical memory was very small, and so the headroom that you have of the kernel space is very small. So when you call the first KAlloc, the first page itself will fail, right? Yes, question? Okay, so there was one function called KInit that I skipped, all right? So I'm going to discuss that later. But let's just assume that, you know, this address space has already been initialized. So this, right now we are working in this address space, right, 2GB to 2GB plus 4MB. So that's a great question. Assuming that there is some headroom above the kernel in this first 4MB, I should be able to allocate a page, right? So it's not really limited by the size of physical memory at this point, it's actually limited by 4MB, this artificial limit that you've used, right, because you've only mapped the first 4MB. So assuming that the, if the kernel size was so large, if the kernel was, you know, let's say 3.9MB, then my KAlloc would have failed, right, irrespective of how much physical memory I have. So if my kernel was indeed that large, I should have mapped more space, more area here in my entry page there. But my kernel is really small, right, not that large, it's less than 1MB, so I have enough space. So when you call KAlloc, you'll be actually allocating space from here, okay? Because, yeah, you're right, at this point I'm not switched, I don't have a heap. My heap is actually very small. What you have done is you have just initialized whatever space is here to a heap. And that's where he's going to serve his request for KAlloc. All right. Okay, so he's going to get a pointer in that kernel-based to kernel-based plus 4MB space, and that's going to be stored in pageJ. The next thing it does is it zeroes out the pageJ. So the pointer that he gets has a one-page size memory area that can be used, right? So page size is 4096 bytes. And recall that our page directory structure itself was one page, right, 4096 bytes. And so what it does is it just zeroes out. So memset pageJ is zero page size means zero out the entire page. What does it mean to zero out the entire page directory? Basically means no mapping exists, right? Because recall that for a mapping to exist, the present bit in an entry should be set. So if you zero out the entire thing, none of the present bits are set. And so there are no mappings in this page directory initially, okay? We can ignore this. This is just an error check. But then it's going to say for K is equal to KMAP, K is less than this, map pages, right? So KMAP is an array of mappings. It's going to look at this array, and it will call the map pages function to create mappings in the page table for that array. What this array is, KMAP, it's basically telling you what are the regions that need to be mapped. For example, so it basically, so static struct KMAP, it says this is the virtual address at which you need to map a region. This is the corresponding start physical address at which this region should be mapped. This is the end physical address, so it also tells you the size of the region that needs to be mapped. And these are the permissions with which you should map it, right? So for example, what we want to do is we want to say 0x, you know, this current base, 2gb value, so 2gb value to this 2gb plus 1 MB should be mapped to 2gb plus 1 MB with all privileges, read, write, execute. Then 2gb plus 1 MB to whatever the kernel code is and read-only data is, that should be mapped to 1 MB to 1 MB plus whatever kernel code, kernel sizes in read mode. You don't want that the code should be writable, just a precaution measure, so you just basically map it in read-only mode. And then for everything else, which is kernel data and all the other memory, that should be mapped in read-write mode in this area to the corresponding physical address, right? And finally, this address 0xFE00 should be mapped identically to the same address in physical memory. So those are the four sort of regions that you need to map, right, four contiguous regions that you need to specify, and that's what this array is telling you, right? So the first mapping is saying, start mapping at current base, which is 2gb, physical address 0xFE00, to physical address 1 MB, extmem is 1 MB, with write permissions, right? So it's just initializing the IOS space, saying, current base to current base plus 1 MB, map it to physical address 0xFE00 to 1 MB with write permissions, this is my IOS space, memory map device. Then the next thing I have is, starting at current link, so current link is what, it's going to be the place at where you will start the kernel, which is 2 gb plus 1 MB, okay, and V2P current link is 1 MB, so recall that we had loaded the kernel starting at address 1 MB, the boot sector had loaded the kernel starting at address 1 MB, so you are going to load the kernel starting at 1 MB at address 2 gb plus 1 MB, okay? The size, the end point of this particular segment will be determined by where the data starts. So the kernel has been organized, the kernel ELF has been organized in such a way that this is current base plus 1 MB, that's the start address, it will first have some code, whatever the size of the code is, and so somewhere the code will finish, let's call that position X, then there will be some area which will be called read-only data, okay, you can specify read-only data, for example, in C if you say const something, then display it as a global variable, that gets allocated in the read-only data, right? So let's say, you know, that goes at Y, and then everything else is, let's say, data. So there are pointers in the kernel, when you compile the kernel, there are symbols in the kernel which tell you that here is the data, here is the read-only data, and so on, so this Y is pointing to, so that's where the data point is pointing. So what the loader is going to do is it's going to consider this as one segment and map it with read-only permissions, right, and it's going to map this and everything above it, so above it is basically heap, after you load it, above this is heap, so everything above is going to be mapped with read-write privileges, right, okay, so that's what's happening here, Kernlink, V2P Kernlink, which is 1MB, to V2P data, right, so wherever data starts, to that point, you map it with zero permissions, zero means read-only permissions in this case, right, if it's writable, then you say PTW, if zero means, that means read-only, and then starting at data, map it from, at V2P data, all the way to fizztop, fizztop is the size of the physical memory, let's say, all right, or the maximum size of physical memory that you support, so all that, all the way up to fizztop, you map it with writable permissions, so that's kernel data, plus all the other memory, that will be used as the kernel's heap, right, and then you map devspace to devspace, which is just FE00 identically, right, so that's what you're going to do, you're going to read this array, which has this, these mappings, contiguous mappings, in a nice readable way, and for each of these mappings, you're going to call mappages, and what mappages is going to do, is it's going to create these mappings, mappages takes an argument, a virtual address, the corresponding size, which is given by fizzend minus fizztop, in the kmap structure, the corresponding physical address, at which it should be mapped, and the permissions with which it should be mapped, so it first takes the page directory, in which it should create the mapping, it assumes that the page directory should already be created, the virtual address, size, physical address, permissions, and if it succeeds, then it will return a non-zero, a positive value, greater than or equal to zero value, otherwise it will return a negative value, what are some reasons for why it can fail, recall that to map pages, it may need to create, allocate more pages, right, right now you basically have a page there, so this is the page there, that is initially completely zeroed out, all zeros, now let's say I want to say, I want to map address 100 to 1000, to physical address 0 to 900, just a hypothetical example, so I want to map virtual addresses 100 to 1000, to physical addresses 0 to 900, what do I need to do, I say okay, address 100 is represented by entry number 0, right, each entry here represents a 4MB region, because these are 2 to the power 10 entries, mapping a space of 4 gigabytes, okay, so each entry, one entry is mapping 2 to the power 32 divided by 2 to the power 10, which is 2 to the power 22, at this space, which is 4MB, right, and recall that this 4MB could be mapped using large pages or it could be mapped using another level of indirection using a page table, right, so in this case 100 is going to be this, the first entry, within the first 4MB, you are going to allocate another page table here, call this page table and in this you are going to say each entry is going to allocate 4 kilobytes, so here you are going to create an entry, saying map to 0 to 900, clearly I cannot just create this mapping, I need to say what is the corresponding page, pages and so I can only do this at page generality, so instead of 0 to 100 to 1000, I will probably have to say map page 0 in VA space to map page 0, so this is just going to map to 0, so to be able to do this, to be able to, so for this kind of mapping I need to potentially allocate a new page to store this mapping, right, and so this allocation could potentially fail, so page directory is a top level structure, recall that our page table is a 2 level structure and so whatever I want to map, I may need to create, allocate pages for the second level and so if that allocation fails, if I am running out of memory, I can probably, I can probably fail, so that is one reason for example, why map pages could fail, okay, yes, so if I want to map let us say 0 to 5th top in one go, I will divide it into chunks and create entries in the page table, because recall that I cannot just, the paging system does not allow me to map all at once, I have to you know divide it into either large pages or small pages and then create appropriate entries in the page table to create that mapping, okay, so the question is that let us say I want to map an entire region from data to 5th top in the page table, right, question is how much space do I need to map this, the amount of space that I need to map this is basically whatever the space is divided by 4 KB if you are using small pages, right, so that is not that much, so let us say the space was, so the overhead is basically you know less than 1% or less than 0.1% actually, right, so whatever the space was, let us say the space was X bytes, then the amount of space that you require to map that those X bytes is X divided by 4000 roughly, right, so that is less than you know 0.1% of X, could you repeat, okay, you have mapped that memory, you have mapped that memory, so there is a difference between mapping and allocation, you have just mapped that memory which means this name is going to refer to this location, you have not allocated that memory, right, allocation means you are not going to, you have basically committed to using it, you just mapped it, you are going to use it later on, okay, the memory that you have allocated is the kernels code and kernels read only code and kernels data, kernels read only data and kernels data, all that has been already there is some content into it which are useful, which should not be overwritten, so all that memory is mapped, but that is a small piece, everything about that you have mapped, not necessarily used, you are going to use it later and you are going to use it using K alloc and K free functions, you are going to manage it using K alloc and K free functions, which mapping, we do not need to store that, can you say your question fully, sure, so how do we do that, so how do we say that this page number in virtual space map to this page number in physical space, we say that using a page table entry, right, so one entry in the page table basically say that this page map to this page, right and so an entry of 4 bytes gives you information about mapping for a region of 4 KB, so it is you know 0.1% overhead of space in that sense, okay, all right, so what map pages is going to do is it is going to fill in this structure called pages such that this area in virtual address space gets mapped to this area in physical address space, okay and it is going to do it using small pages, all right, so recall that I had said that you know one common optimization used in mainstream kernels is that you use large pages to map the entire kernel, right, that save space but XV6 does not do that, I mean it is not, so XV6 just to make things simple uses small pages to even map the kernel address space, so all these regions are going to be mapped using small pages, right, in this case for example if I wanted to be smart about it, I would have probably said look this area is 1 MB, so I am going to use small pages to map this area because you know 4 MB pages are too big to map this area, this area from kernel link to V2P data, this is also very small, I said it is less than 1 MB, so even this is it does not make sense to use large pages, I am going to use small pages for this but this area from V2P data to fizz top and assuming my fizz top is very large, right, like you know 100 MB or 200 MB, then this area is for potentially mappable using large pages, right, but we are going to forget about it, we are going to say we are going to map all these areas using small pages, right and finally this area is also small, so large pages may or may not help, yeah, I mean perhaps large pages will help here too but in any case we are going to use small pages to map all this, fizz top is just a constant defined in the kernel which basically says what is the maximum amount size of physical memory that xv6 supports, right, so fizz top is just set up to hexadecimal E, I think EN60 which is 224 MB, right, so just irrespective of the size of the physical memory, it maps data to fizz top identically, okay, so if the physical memory was larger than fizz top, that area is not accessible, right, above fizz top area in the physical memory will not be accessible, if the physical memory was less than fizz top, let us say the physical memory was only 100 MB, then you have just unnecessarily mapped extra area but that is okay, I mean if the user ever accesses that area, he is going to get some error, right, some exception, okay. Okay, let us stop here."}