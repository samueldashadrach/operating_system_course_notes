{"text":"So welcome to operating systems lecture 8. So far we have been looking at how an operating system implements abstractions that it does and the first abstraction we looked at was the address space and we said look segmentation is one way to implement address spaces and there is something, there is a structure called a global descriptor table which lives in the physical memory. It is roughly of the size 2 to the power 13 which is perhaps the reason why it should live in the physical memory right because the chip will not have that much capacity to be able to store large structures like this. So structures like this which are relatively large need to be stored somewhere else and the typical place they are stored in is memory right and then but on the processor you have this register which is called the global descriptor table register which points to the GDT and that is how the hardware knows where to look for when it is actually executing the MMU operations right. Now these segment, these registers code segment, data segment etc. these are called the segment registers and within them they store the segment selectors right. Depending on the instruction a virtual address will choose one of these registers. For example if it is, if you are dereferencing the instruction pointer you will go through the CS register. If you are dereferencing you know any regular data the default segment will be the data segment. So you will dereference the DS register. If you are dereferencing the stack through ESP or EBP point register then the default segment will be SS register. So there are certain default segments and then you can also override the default segments by explicitly specifying that this is the segment register that I want to use for this particular address. In any case the segment selector is used to index into the GDT right. So the algorithm inside the hardware is that it will first dereference GDTR. It will first read GDTR to find the address of GDT. You know add the selector to that value to understand where exactly the descriptor lives. Read the descriptor. Get the corresponding base and limit values. Perform the appropriate operation of PA is equal to VA plus base and checking if VA is less than limit and if these checks succeed it actually uses the computed physical address to index the physical memory all right. Question? Is the value of GDTR read at every memory access instruction? That is a great question. In other words for every memory access do I make another memory access? So does every memory access that a program makes does the hardware need to make two memory access one to the GDT and then one to the real physical address? Well logically speaking yes but actually no because you know these entries get cached inside the chip right. So there are you know there are semantics on you know when the cache gets when the caching takes place and when it gets invalidated and let's ignore that discussion for now but you can imagine that you know the select the descriptors for all the six segments that are present on the CPU they just get cached inside the CPU. So you don't have to go over the bus every time to access the GDT descriptor right. So that's an optimization but let's look at the semantics for now all right. So each segment descriptor has a base and limit and it also has permissions which basically says at which privilege level am I allowed to go through this segment all right. So the privilege level is determined by the lowest two bits of the CS register. So if the lowest two bits of the CS register are zero which means I'm executing in privileged mode I can you know I can access any of the configured segment descriptors here or I can dereference to any of the segment descriptors. On the other hand if it's three then I can only dereference segment descriptors that have permission set to three right or unprivileged all right. So far so good basically this what this allows you to do is every process will have a private address space nobody else can touch it. The OS will have its own protected address space no process can touch it and moreover each process has a uniform address space you know starting at zero for example right. So you do the process the compiler or the linker does not need to be worried about where the process will actually get loaded. So the loader and the linker can become completely independent all right. The next thing we said was look that's fine across this is how operating system implements address spaces for processes but a process needs to do more in particular there needs to be a way for a process to make a system call. There needs to be a way for the OS to actually take control away from the process on some external event like an interrupt from an external device or interrupt from a timer device for example especially because I need to implement protection. So one process should not be able to run away with the CPU. So I should be able to run after every predefined time interval. Moreover I should be able to get control if the process performs any illegal action like divide by zero segmentation violation. So the word segmentation fault and actually you know has historical roots in the segmentation procedure. So a segmentation fault means that you violated the segmentation rules right. So you actually tried to exceed the limit and so you violated the segmentation rules and that's how you know that's why it's probably called segmentation fault. So to facilitate this and also system calls there's a mechanism called the interrupt descriptor table or IDT as I'm going to call it and the idea is that in case of an event which involves which is either an external event that a device needs attention it asserts the interrupt pin or it's an internal event that application actually executed something illegal or the exceptional condition. Then you know the processor is going to stop execution there for the process and look into the IDT to figure out where is the handler of this particular condition right. The condition could be an external device asserting something or the condition could be internal. In either case there will be a number associated with that particular condition and that that number is called the interrupt vector. So the interrupt vector will determine which entry in this IDT should be dereferenced and that entry is going to be used to find the program counter of the handler right. So the each descriptor in the interrupt descriptor table contains a pair code segment and EIP which is basically a pointer to the handler of that particular condition right. So for example if you know if the network device asserted the interrupt pin and you have assigned it number two then you know you should have the network device handler at this particular address or if you if there was a segmentation violation then you should have the segmentation fault handler at this location and all. And these handlers will typically do what they will either you know execute the device driver logic in case it's a it's an external interrupt or if it's an exceptional condition they will execute the appropriate logic to deal with that exceptional condition. So for example if it was in segmentation fault the operating system would say they just kill the process all right or it could convert that exception into a signal and pass it on as a signal to the Unix process right and recall what a signal is. A signal is nothing but interrupting the process execution and making a fault to the signal handler of the process right. So in some sense the abstraction of Unix signals is is very much inspired from what happens at the hardware level in terms of exceptions and interrupts. When interrupt also causes a handler to get executed and and the signal got but in this case is a hard it's an interrupt handler in case of process it was a signal handler which was the process are registered. The process was able to register signal handlers for itself. Similarly the operating system should be able to register interrupt handlers or exception handlers for itself. The mechanism to be able to register signal handlers is provided by the OS. The mechanism to register interrupt handlers or exception handlers is provided by the hardware right okay all right. So so we understand handlers so far. The other important thing is that the compute the code segment could actually be a privileged code segment. So even if I am executing in unprivileged mode if this code segment has last two bits set to privilege which is zero then you know when the interrupt is going to occur it's going to start executing in privileged mode and that's required because you want that you know whatever code you are going to have for device drivers or for exceptional conditional handling should run in privileged mode right. So so the hardware designers provide that facility because by allowing you to specify any CSA okay all right. So with that let's look at what happens if you know if so before I start an interrupt or an exception so I mean I use the word interrupt for anything that's from an external source like external device like a timer or a disk or whatever and I use the term exceptions for something internal like a segmentation fault or or divide by zero etc or an illegal instruction was executed etc. So an illegal instruction is executed one example would be a process tried to execute the a privilege instruction like LGDT right. We saw that loading the GDTR is a privilege instruction if you are running in unprivileged mode and the process tries to execute the privilege instruction LGDT right. You recall the LGDT instruction which loads the GDTR you're going to the process is not going to be allowed to do that and what will happen is an exception will get raised and the operating system will come into action and it'll decide what to do with the process right. All right and another thing the IDT itself is also stored in memory once again IDT is a relatively large structure cannot be stored on chip completely so rather the IDT is stored in memory and there's a pointer called IDTR inside the chip which better look for IDT just like GDT. All right so now let's say I get a trap so I'm going to I'm going to use the word trap as a general term for interrupts or exceptions so I could get an interrupt I could get an exception let's just call them a trap. There's a question. Can we change the entry in the IDT. Let's hold that thought for a moment that's a great question but let's let us first understand how this works and then we'll talk about security you know what can what should be a process be able to do and what it should not be able to do such that you know it's not able to gain control of the system. So let's say I get a trap in kernel mode. Kernel or you know you can also say privilege mode. So I'm going to use the privileged unprivileged or kernel user same thing so kernel is privilege mode kernel mode is privileged mode and user mode is unprivileged mode. So what happens is let's say I was executing and a trap occurred so what will happen is let's say this was my stack pointer this was the value of my stack pointer as soon as a trap occurs what I'm going to do is I'm going to push the old values of ES and old value of EIP and I'm going to set my CS and EIP registers to the values that I get from the interrupt descriptor table and I'm going to start executing. So I got the trap in the kernel mode I look I use the ESP value at that time to push the old values on the stack and now I use I start executing the interrupt handler right this is very similar to how signal handling was happening right a signal comes you just execute that as a as a function call as an asynchronous function call. Similarly this is doing the similar thing you know an interrupt came or a trap happened you just executed the handler as an asynchronous function call using the same stack that the kernel was using. Another matter of detail apart from CS and EIP it also stores old E flags so the interrupt descriptor table entry could also potentially contain flags register or certain flags and when the interrupt gets actually starts to run the semantics are that you're going to replace not just CS and EIP you're also going to replace certain flags some flags. Before you start execution of the interrupt handler at this point we're also going to replace some flags with the values that are present in the descriptor and because you're going to change things you also need to save them and once again you save them on the stack. This is clear? This is yeah so we are talking about a trap received in kernel mode so let's say there's a there's an interrupt while I was executing in privileged mode this is what will happen so it will just push things on whatever the value of ESP is currently okay. Don't we require storing general-purpose registers? Yes we do require saving more things but this is the minimum that the hardware saves for you and now the control has been transferred to the handler and most likely if the first thing the handler is going to do is save the rest of the state it may you the handler is yes part of the OS. See basically the hardware has to change the values of some registers to be able to execute the transfer and so whichever registers it changes whichever is the minimum set of registers that needs to change those are the set of registers it saves. Other things it doesn't need to change it's really up to the software writer whether he needs to save them or not. These kind of things the software writer won't have been able to save right because you have to save where to execute the handler and so before that I mean it's a chicken and problem so the hardware has to come in into the middle and says okay these are the things I will save and the rest of things you can save. So there are certain flags I'm going to look see later which need to be saved by hardware so can't why can't E flags be also saved in software right so there's a reason for that and we're going to discuss that later. So this is what happens on a trap entry and then you know the handler is going to execute. Typically the handler is going to execute on the same stack so it's not going to change the stack value right so just like an asynchronous function call you just execute the handler and then you want to return from the handler right. In case of a signal when we saw for Unix I just executed the return instruction and I will get back to where I was right because the semantics of the signal entry was that the OS used to push the return address on the stack and so when the signal handler used to call return I used to pop the return address on the stack and get back to where I was right. In this case also it's going to be similar except that it's not a regular function call so I cannot just use return to return because return is only the semantics of the return instruction is that I just pop the stack and look at the EIP and that's it. I just pop the EIP and set that it has nothing to do with CS and E flags yeah they call it the return instruction. So we need a special instruction called interrupt return IRET. I'm going to call it trap return and here there's if the ESP is pointing at this place an interrupt return is going to pop the stack and put this into put the first value into EIP register the second value into CS register and the third value into E flags register right. So this is the semantics of the IRET instruction what's going to do is it's going to look at the current stack pointer and pop these pop the first three words on the stack and fill these registers with those values all right so this is interrupt from return from interrupt. Yes so right now I'm talking about a trap in the kernel mode right so I because I was executing in the kernel mode already so ESP is of the kernel all right so I'm already executing in the kernel mode so ESP is trusted in this case so I can I can do these things. Now next I'm going to talk about traps in the user mode that was the discussion that we were having yesterday. As a matter of additional detail there are some vectors the some interrupt vectors which actually push forwards it's just a just a matter of matter of the fact really there's no there's no fundamental behind it but there are certain vectors for their which there are certain extra there's one extra value that's pushed that's the error code all right so for example the page fault or it's like sorry so certain for example you can say you know a certain exceptional condition could additionally push this error code for the handler to know exactly why that exception occurred right so certain exceptions can occur because of various reasons and so an extra value is pushed on to the stack to indicate that right so the only the hardware knows exactly why this exception occurred so one exception could actually be representing multiple conditions and so error code basically tells you which of these conditions is actually the reason for that exception. What this means is because some vectors push the error code and others don't the handlers need to be appropriately set up such that they understand this right so the the handler for the vectors which push the error code will be set up to know that an error code is already there and the handler for which the vector which do not push the error code should know that it's not there. Just to simplify things typically on x86 and OS handler will all the handlers for which the error code is not pushed the handler will the first thing it will do is just push a zero value there so that the stack becomes uniform right so it can it can assume a uniform stack frame. If there was no error code pushed by that vector the OS in software will just push a zero for that particular in that particular handler. On return the the IDET instruction does not assume the presence of error code all right irrespective of what happened here so it's the responsibility of software to pop the error code before it calls IDET. All right okay now let's look at a track in user mode or let's say unprivileged mode. Once again I was executing and here's my stack pointer that's where it's pointing and a trap occurred now what should the kernel do can it do the same thing can it just push so clearly it needs to override certain registers for example it needs to override CS and EIP definitely it also needs to override E flat okay now question is where does it push the old values of these registers because it needs them at interrupt return so where does it push them want to put them on stack but can I just push them on this stack why because this particular value of this register is modifiable by the user and the user could set it to anything which cannot be trusted right I don't trust so the model is that I don't trust the process I don't trust the process in the sense that I won't let the process bring down the whole system no matter what the process does it should never be allowed to bring down the whole system in this case if the process had just set ESP to 0 for example right or some you know some invalid address and then right so let's say ESP was set to 0 and then it executed some exceptional condition which caused a trap then what will happen is the kernel will try to push on a full stack right 0 cannot be decremented any further and so it will get into an infinite exceptional condition and the CPU will actually halt right so that's not that's not acceptable so what I'm going so what's really needed is that on us if you receive a trap in user mode you should also switch the stack pointer before you start pushing things right so so what happens is on a trap it actually switches to another stack that stack is let's say ESP 0 and then on that stack it's going to start pushing things notice that because I'm modifying more registers now unlike the previous case where I was just modifying CS and EIP I'm now also modifying ESP in fact I'm also modifying SS right so the semantics are that I'm going to modify the entire virtual address which is represented by SS colon ESP so initially if it was SS colon ESP now it becomes SS 0 colon ESP 0 and so I need to save the old values of SS and ESP and I want to do that on this stack right so what I'm going to do is I'm going to push five bytes here and I want to say let's say old SS, old ESP, old E flags, old CS these are the things that the hardware saves for you and now the interrupt handler is set up to be able to run in a secure environment so it has a secure stack that I didn't trust and it has it is on the right instruction pointer and now it can start running and it may want to say more things and typically what it will also save those things on the same stack on which it was started because this is a trusted stack anyways okay the second one is the kernel stack this was a user stack now now what happens if when the kernel executes the irate instruction so now the interrupt handler will execute or the trap handler will execute in the in the on the kernel stack and eventually it will want to return and it should actually return to exactly the same point in the user space where it actually left off right so once again it's going to call the irate instruction and the semantics of the irate instruction is going to once again so you know let's say this was the ESP at this point it's going to pop out the first three words and set up set those up as CS, EIP and E flag just like before but now it's going to see that oh the CS is actually a an unprivileged CS the CS that it's actually popping into the into the register is actually an unprivileged CS it can see that from its value and so it's going to realize that because it's because I transition from a privileged to an unprivileged I'm transitioning back from a privileged to an unprivileged mode there must have been two more words that have must have been pushed and so it also pops off those two words and actually pops off five words to set to basically reload these registers back again in the previous case irate was just popping three values in this case irate is popping five values how does irate know how many values to pop by looking at the value that was popped in the first three words by looking at the value of the second word that contains the CS all right and so when you execute the irate instruction you are actually going to get back to the user stack because you have changed the value of SS and ESP so you are actually now going to start executing in the user stack with the exactly the same EIP at which you left off okay okay so now let's talk about security so what prevents a user from being able to take control of the system we said a user can is basically sandboxed within his own address space because firstly he cannot modify GDTR secondly we said the GDT itself should live in a portion of memory that's not accessible by the user right and thirdly these the values of these selectors can only be set to one of the values that have been put in the GDT right and the OS should be careful that it only puts the right values permissible values in the GDT right so that's how I was ensuring that a user is not able to jump out of its address space question okay okay good question so how do we ensure that the in the kernel mode ESP never becomes 0 or ESP never underflows right or I'd never done out of stack so this is the this is something that an OS designer has to be careful about nothing in this world is nothing is infinite right infinite so even in the user mode a stack is never infinite it's just an inclusion of infinity right so if you ever try to cross your boundaries you're going to if a process ever crosses its boundaries it's going to get a segmentation fault okay an OS is should ideally never cross its boundaries so the OS designer should write his OS in such a way that there's a bound to the maximum stack stack length that you can have all right I'm going to see how that's done so an OS designer or OS writer or kernel developer has an extra bound that you know you cannot grow the stack too much there's a maximum bound to how much a stack can be typically a stack would be for example the Linux kernel has a stack of one page of around 4,000 bytes or maybe even 8,000 bytes right so between 4,000 to 8,000 bytes are enough in general for a stack right even your xv6 kernel which we're going to look at an academic kernel called xv6 later it also has you know 4,000 4096 bytes of stack and that's enough okay all right okay so so we saw how this is basically saying that a program can never jump out of its address space it's also saying that a program can never execute an instruction which is privileged because I'm going to run it in the privileged mode etc okay and a program can never lower its privilege level so once you have set up the privilege of the CS register I cannot just lower the privilege level but we also saw that the IDT is a way for the process to actually lower its privilege level right so for example I can just execute some exceptional conditions and I'll now be executing in privileged mode so the first thing is that the OS should ensure that all these entries all the handlers of the IDT are appointing all the entries in the IDT are pointing to valid values if one of these IDT values is pointing to some garbage then an OS can actually cause that particular vector to get fired and you are going to actually try to execute some invalid instruction and the system can get down the first thing is the IDT itself should have completely same values the second thing is the instruction to load the IDT which is the LIDT instruction which just loads the IDTR should be a privileged instruction right a user shouldn't be able to just say LIDT because if the user can say LIDT then you can just take control of what gets executed in privileged mode so the instruction LIDT should be a privileged instruction right the third thing is that the IDT itself should live in the OS address space it should not be able to it should not be visible to the any process so only the OS can set up these values the OS needs to be very careful about setting up these values so the user cannot take advantage of any bugs in the way plus you basically ensure that this structure is not modifiable by the process right okay question okay is it possible that a process wants to handle an interrupt in a different way than an other process it is a matter of what abstraction the OS is providing to the process in the abstraction that you've seen so far that's not possible a process has no idea what an interrupt means only understand system calls and signals okay so it doesn't make sense to say that a one process should be able to convert to control the handler of a particular interrupt right a process can control the handling of a particular signal right that's that's a different of course you know so what you have what you put is you put a layer in between the hardware and the process and you said that this is these are the permitted things that you can do and I'm going to implement those things right and we have seen one type of abstraction that are the unique distractions and then there are other types of abstractions which actually allow the thing kind of thing that you are saying all right and there are performance advantages to be able to do that right but it also makes things more complex and etc and we're going to look at those trade-offs later on okay all right so in this figure when I said that when a trap is received in user mode actually switch the stack to SS 0 and ESP 0 there is a minor matter of detail where does the hardware get these values SS 0 and ESP 0 from there needs to be some way of telling the processor look these are the values of SS 0 and ESP 0 before you actually before the OS actually gives control to the user you should set up SS 0 and ESP 0 appropriately so that if a trap occurs while the process was executing the hardware knows that this is what you should load right and on x86 there is a structure called task state segment which allows you to do this and there are more details they're going to find out in your programming assignments I'm not going to go into detail let's just for the purposes of the of our discussion let us assume that there is some place where you can store these values and tell the hardware that here's where you should pick up these values from right when you get an interrupt and usable okay another thing I would point out is that notice that when I'm talking about the semantics of instructions like irate while the semantics have been designed in such a way that they complement or the bracket the operation at an interrupt entry or they you know so whatever the interrupt entry is doing I rate is undoing but actually irate exists as a separate instruction in itself right which has these semantics that's going to pop off the first three words and load them into these registers and depending on its values maybe pop off two more words etc so actually between the execution of the entry between the entry and the return the interrupt handler could potentially modify these values or whatever reason typically it will not modify these values but sometimes it may right one example where it may modify these values is for example when you want to set up the first process or let's say when you implement the fork system call right so what happens in a fork system call okay before we discuss that let's also talk about how system calls are implemented we discussed that lesson yesterday but let's just review that so apart from interrupts and exceptions there are also something called software interrupts these are interrupts that the that the program can actually invoke so instead of some exceptional condition happening or some external device saying that I want an interrupt to get in handler to get executed the program itself could execute an instruction like in three it's a one byte instruction or in oh which basically says invoke this particular interrupt or trap the semantics is that this is going to simulate an interrupt of vector 3 right this is going to simulate an interrupt of it vector whatever O stands for overflow in this case right the semantics for this is that this is basically used for debugging so this is the breakpoint right so if you have wondered how GDB works for example one you know it basically so if you put a breakpoint at some point you say I want to stop the execution at this particular point right at this particular value of the instruction pointer what GDB does one way to do that is basically that GDB writes this particular instruction in three on that particular byte so let's say I wanted to get interrupted at EIP 1000 so what GDB going to do is it's going to write in three instruction at 1000 going to replace the original contents of that value of that memory location and put in three there will happen is when then when the program gets executed as soon as it reaches that point it's going to execute in three and an interrupt going to get simulated the interrupt handler will be the OS interrupt handler and in this case the interrupt handler will know that this is a breakpoint interrupt handler the breakpoint interrupt handler let's say what it does is it converts the exception into a signal that it gives to the GDB process and so the GDB is installed a signal handler which basically says okay stop execution and return back to the user with a prompt and they ask for the for the next command from the user right so this is one way of implementing breakpoints right so a good example of why software interrupts are used okay similarly in interrupt overflow is an overflow condition so this basically says that if you know if in the E flag register the overflow bit is set then cause an interrupt so the the way the hardware designers imagine this to be used is basically you perform some computation and then you execute the into instruction so if the execution actually created an overflow it will cause an interrupt if it didn't cause an airflow overflow it will not cause an interrupt and so the idea is in the common case when there was no overflow you will just you know very quickly go to the next instruction you don't have to have if then else kind of logic in your code so this makes gives you a very nice very a fast way of doing this kind of exceptional condition handling right and of course then there is the normal instruction which can take any vector number and this can basically say simulate this particular interrupt right and this is what we use for system calls example a particular vector number let's say you know the Linux kernel had been using the number 128 or hexadecimal 80 to do the system call so basically means if a process makes int $0x80 it's going to simulate an interrupt at vector 0x80 and the handler at 0x80 is going to assume that a system call was made it's going to also assume that the arguments of the system call and the system call name itself is stored in certain places for example it's stored in the registers and so it's going to read the value of the register to figure out what the argument what what system call I need to execute for example exec folk etc and what are the arguments for to it right for example this the address of the string for exec etc okay the system calls are also implemented by using this interrupt descriptor table structure and okay and so and as and so we were discussing how irate can be used so we said that irate can actually irate has the semantics and an handler may want to actually change these values before the interrupt runs and one example where you would do that is the fork system call right what happens on a fork system call you make a system call the handler is a system call handler it figures out that you're trying to call folk what it does is it creates a new address space and copies your address space into the new address space one way to create a new address space is get that much get the same amount of memory in physical memory right copy all the contents set set up a new base and limit in your internal data structure and and set up the stack in this way such that EIP CS E flag ESC SS is identical to how it was in the process which called the fork with the only difference being that the return value should be different right so how does it do that where is the return value stored yeah let's say it's the return value of the system call is in the ES register so it just changes the value of the ES register and executes the irate instruction so it's a set of new stack it copies these values it maybe changes some register and causes irate right another way you know a fork system call could potentially run is basically you know store the value on stack right so let's say the return value is coming on stack even that's possible what what the what the handler will need to do in the new process is dereference the stack pointer of the user and maybe change some values there before calling irate right so the stack will actually see new values slightly different values let's say similarly you know when the kernel boots there's really no process there is really no user mode everything is running in privileged mode so when you create to create the first process you know for example the init process on on Linux you know what the kernel will do is it will just set up the stack in a certain way it will set up the address space in a certain way such that you know a certain executable is loaded in the address space and now we'll just call the irate instruction and so now the first instruction of init starts executing so even though init actually never existed before the irate, irate is basically simulating as though I'm returning back from a system called irate mate right so another I mean basically a kernel can set up a fresh stack and still call irate or it can modify these values and still call irate to implement the right functionality okay can't it just move so you cannot just move into CS right there's no instruction that says move into CS there's no instruction that says move into AIP there are instructions like ljump right so that's an interesting question can you just say ljump to this particular value and let's see why is that not allowed so you also need to change the stack so you will basically need to load the stack from the user mode to the kernel mode and you're going to call ljump let's see I believe it's not allowed in the processor so you cannot just say ljump from one privilege level to another privilege level right but let me let me confirm that so exactly why the x86 architecture doesn't allow you to just do ljump but more importantly even this an atomic operation right so you can just basically set up the stack and the AIP in one go as opposed to being it we doing it in multiple instructions so first you will have to load the stack and after you have loaded the stack you're still executing in privileged mode and so that has also has its own security implications you know executing on an unprivileged stack in privileged mode has its own problems right how do we do that that's easy right the parent can just return so for the parent it was just a system call a regular system call right so just out just like it returns from a regular system call it's going to call I read and going to return from it for the child you need to create a fresh stack right so so here's a process it made a system call right the system call is basically internally figured out it's a fork and so it created new state and create a new stack it added a new process to its list of processes and now it just calls I read on the original stack right so the prop the parent can just continue as it is right and now the child on the other hand will get will continue in on its new stack we call I write on both right so only one prep process enters the kernel and two processes exit the kernel and the stack so we are copying the entire address space and we are setting up the stack pointer to be identical so that basically means you're copying the stack okay I see so what basically okay so now you're asking how many kernel stacks there are right so that's your question good so okay so how so there are two ways the kernel is implemented one is the process model where there is a kernel stack separate kernel stack per process right in this case what will you do on a fork you will create a new kernel stack and you will copy the entire kernel stack so apart from the user address space which has nothing to do with a kernel stack and so you're going to have a separate process kernel stack per process so when you fork you're going to actually have to stack and you're going to call irate on each stack independently so that's how you implement one entry and two exits there's another model in which you can implement things which is called the interrupt model so this is basically you know how you implement your kernel in the interrupt model there's just one kernel stack per CPU so let's say there's just one CPU in your system then there's just one kernel stack and so now what the kernel needs to do is that it needs to store so what will happen is that there's just one kernel stack and that's the value that goes into SS 0 and ESP 0 that the hardware knows and and that's permanent and so whenever you enter you enter on that stack but you are going to when you switch so let's say you know when I was let's say a function process make a system call and I was executing on the stack and now I created a new process called child and now I wanted to switch to the child so what I'll do is I'll save all the contents of the kernel stack in some other data structure and load the content of the child stack from his data structure into this stack right so eventually the same thing you basically need separate states in the kernel which simulates a stack per process right in this case you're having you're actually having a kernel stack per process in this case you actually have only one stack which is visible to the hardware but internally you are you are swapping state to basically fill that stack right in this case you will actually tell the hardware so on each context switch you're going to tell the hardware that this is this this is this is the value of SS 0 and ESP 0 you should use right on every context switch you change the hardware structure in this case on every context switch you don't change the hardware structure you just do this internally one of them we only have one CPU let's assume okay and then yeah so you cannot let's say there's just one CPU so what will happen is one CPU one process made the four calls it created a new process it added it to the list of processes that are possible to run right and now let's say the parent continues to run the parent is going to call I read and now parent can continue to run and then let's say the parent says I want to get out of the CPU or let's say a timer interrupt occurred and the OS forcibly brings him out of the CPU and now this process is turn comes and so now he gets to run and now he will collide it no we popped out things from the parent stack so we have a separate stack per per process right so it popped out things on the parent stack the child stack still remains in the interrupt model you know it's basically the same thing except I mean you basically storing the value with which the stack needs to be initialized when it gets context switched in some data structure right so let's say in that process in the list of processes you also think you know this is the these are the values of the tissue initialize the stack before you started running so it's I mean there's no fundamental difference really in one case you are exposing it to the hardware in the other case you are keeping things internally okay all right so yeah question right so what will happen so this seems to be confusing people that what happens in case of one kernel stack let's just this is one kernel stack all right but each time you context switch you are going to reinitialize that kernel stack with certain values and so for in case of a parent and child you store that you know this is what you should initialize it before you start running it that's the difference in the code first clearly in the OS address space so where are these values stored clearly in the OS address space how they are stored in some data structure which is maintaining the set of all the processes and associated information right in any case when I have a separate kernel stack or process I'm also storing the stack with the process right so this is this is your stack this is my stack this is his stack etc and so I'm going to load the ESP with that stack in this case the ESP remains the same I just initialize the memory location that's the only difference is it possible to make two copies of the same thing on the same stack I mean intentionally or unintentionally okay and then why it has a lot of problems so the question is can we use the same stack for both the parent and the child and actually have two frames one for the child and on the parent and use the same stack not having to context switch there are also other processes in the system right so you know I mean the cleaner way would be that you basically say that you know this is this is yours this is how you should initialize things so other it's possible that between the parent gets to run and between the child gets to run the other process that get to run in the middle so you know why would you want to do that okay all right so you are programming assignment you are you are now roughly ready to actually start on your programming assignment and you should start on it immediately okay also there's a homework due next Thursday so you should also start looking at it all right okay"}