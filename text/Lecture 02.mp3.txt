{"text":"Welcome to operating systems lecture 2. Yesterday, we discussed that software for computer system is usually very complex. It involves lots of different things including event handling for devices, running different programs, loading different programs, writing new programs and so on. And it is important from a manageability and a point of view to structure or your system in such a way that it is it becomes more manageable. And that is that is the that is in some sense the area of operating system. And we discussed then an operating system is in some sense the lowest layer of software that sits on top of hardware. And it exposes certain APIs or interfaces to the applications, so that they can use those interfaces to do all the things that they would want to do, right. And we said that you know in general designing such an API is not trivial, it is little complex. And we started with looking at one particular operating system Unix, which was you know one of the first very successful multi processing operating systems. And on which many current operating systems are modeled, and we started looking at what its interfaces, right. Particularly, we started looking at one powerful program called shell, which lot of us use in daily life. And see how a shell is implemented on top of Unix abstraction, right. And so we said look the shell is actually implemented as this loop, which is you know by the while statement. In this loop, the first thing it does is write to its file descriptor number 1, a string of length 2, right. That is the dollar prompt that you see on your screen. The file descriptor 1 is a special file descriptor, which points to the standard output. The standard output could have been opened by the shell itself for example, or it could have been inherited from its parent, or you know whatever other ways. The file descriptor could point to a file, it could point to a device, it could point to the network, that allows you to write the environment agnostic code, when you are coding something like that. So, the same shell can execute both on a serial port, and can execute on your screen. Then there is this imaginary function that I have written here, which is called read command. You can imagine, so what this read command function does is, it invokes the read system call, right. Once again, as a function that the kernel provides to an application, right. So, inside the read command function, it must be calling the read system call, and it must be, and it is calling the read system call on file descriptor 0, right. The file descriptor 0 is also a special file descriptor, which refers to the standard input of the program. And once again, it can be initialized in any way, exactly as it was initialized for the standard output. It reads command from the standard input, parses them into the strings called command and arg. You can imagine that this command is an array of characters, and an argument is also an array of strings, where each string is an array of characters. Once it has parsed the command from, which it has read from the standard input of the shell, it needs to actually execute that command, right. So, let us assume that the command is, the name of the command can be parsed as a name of a file on the file system. And so, what you are going to do is, you are going to execute that file. You are going to pick up that file from the file system, and you are going to execute it. But once again, you cannot just execute a file in, you know, in the context of your own process. The shell is running in a certain container, which we call the process, which is again an abstraction that Unix provides. And so, the way it works is that, Unix allows you a system called fork, which clones the current process. So, which means it makes a copy of itself, and creates another process, which we call the child process. The new copy of the process is identical to the parent process, except that its process ID is different, and the return value of the fork system call is different, right. So, we assign the return value of the fork system call to this variable called PID, which is, you know, our own local table. And then, we check its return value. If that return value was 0, it means that we are currently executing this code in the context of the child process. In which case, we execute another system call called exec, which takes the command and the argument, and tells the OS to execute this command in the context of the child process, right. So, the parent process remains completely unaffected by this operation of exec, which executes only in the child process. Antics of the exec system call are that, it will completely forget about the current process, in the terms of the memory content, load the executable into the context of the current process, and started running. So, in other words, once you call the system call called exec, control actually never reaches this point, right. Because, once you have called the exec system call, you have loaded the new executable, you have transferred control to the first instruction of that executable, and that executable has completely forgotten the context in which it was loaded, right. So, the process is completely sort of initialized in some sense, right. So, you know, you could, so you could write anything here, but it will not get executed, that is the semantics of exec. Exec never returns, right. But, executing process or any process can exit, right. So, there is another system call called exit. This is again a system call or a function provided by the kernel, that a program, that a process can call, and the semantics of the exit system call are that the process will terminate, right. And all the resources belonging to that process will get freed, all memory etcetera will get freed, whatever belongs to that process. So, that is the semantics of the exit system call. Often, when a parent spawns or forks a child process, it was also interested in what happened inside the child process, whether the execution of the child process succeeded, whether it failed or what was its return value, for example, right. So, Unix allows you to specify an argument to the exit system call, which let us call the exit code. So, you can, this is just an integer, which can be thought of as a return value of the process as it exits. And the parent, so that is, you know, that is how the child executes, calls the exit system call. And the exit system, the program that is loaded inside the exit system call, may or may not call exit at some later point of time. The parent can monitor what is happening to the child by calling the wait system call, right. So, the semantics of the wait system call are, in this case I am calling it with the argument 0. It basically means, wait till any of my children exit. As soon as this child, so in this case, you know, a parent will only have one child at most living in the system, right. So, shell program, the shell process is one process and you will only fork and then you will wait. So, at most you will have one outstanding child in the system, right. And so, when you call wait 0, you are basically waiting for that particular child that you just found. So, wait, the semantics of wait is that it will block till the child is running and it will return as soon as the child exits. Further, the return value of wait is the exit code that was passed as an argument to the exit system call in the child. So, if the child called exit with return value 10, then the return value of the wait system call in the parent will return 10. That is the limited way of inter process communication between the child and the parent. So, what happens if the child does not call the exit system call, but crashes. For example, it touches illegal memory and causes a segmentation fault. Even in that case, the wait system call returns with the appropriate error code indicating what happened to the process. So, either, you know, either you will get the exit code inside the return value or you will get a special code, which indicates that the process crash and why did it crash. Parents can get that kind of information for a child. It is a limited form of what are called inter process communication, IEC, inter process. Once again, if I were to draw the diagram of the OS, this is the OS. This is, let us say the hardware and these are different processes. Processes are making system calls to the OS and getting answers to the system call. One of the system calls is the fork system call, which actually creates another process here, such that it is identical to the original process that was created. These processes are more or less isolated from each other. So, if I am, you know, if I instantiate a variable here and I write something to it, it is completely in my private space as opposed to a variable that is instantiated in this particular process. However, often you need to communicate between these processes for various reasons. And one way to communicate is what we saw is the exit code between the exiting process and the waiting process. This form of inter process communication is very limited, because it is just, it can only be used between a parent and a child. I cannot use it from any or any two arbitrary processes. Also, it can only be used if the child exits. So, it can only, it is a limited form of inter process communication and it is only useful when one of the processes are actually exited. We are going to see more types of inter process communication very soon. So, exit code is going to tell you what happened to the process, the child process. And, you know, most shares would typically, you know, have an option with say, whether you want to display the exit code with which the process actually, your command actually, whether your command succeeded or failed. One of the standard conventions on Unix, for example, is that if a process execution succeeded, then it will exit with exit code 0. If it failed, then it will exit with exit code 1 or, you know, it can or some non-zero exit code indicating the failure condition. And, this third if condition is what? So, the first one was, if it is, if the return value of O equals 0, which means it is a child. The second one was, if it is greater than 0, which means it was failed. And, the other, the remaining one is, when it is less than 0, which indicates error in the 4 system calls. So, the 4 actually never happened, right. If the return value of 4 is less than 0, it basically means that the 4 never happened for whatever reason. There can be many reasons, for example, the process ran out of memory or something else, recording, right, ok. So, this kind of interface, though seems, you know, rather easy right now, it is actually not so trivial to come up with, when it was first in a search, right. So, there were many iterations before, you know, on what this right interface should be, before Unix was actually became popular. And, as you can see, this interface of, so this interface really involves, you know, something like a 4 system call, an exit system call, the ability to name file descriptors, and to be able to call open, read, write, close on these file descriptors. The exit system call, which returns an exit code, and the wait system call, which allows you to wait on an exit code. And, all these things, what they allow you is composability. So, it allows you to compose one program inside another program, able to spawn another program, and treat it just like a function call, for example. So, you just spawn another program, let it run, let it run asynchronously, collect its return value, it sort of becomes an asynchronous function call. You can also pass arguments to that, one program, process, by, you know, specific arguments to that one process, by saying, you know, what the file descriptors are going to be. You can initialize the standard input, standard output, standard error, based on what you want it to be. And, that sort of gives you a very nice composability, composable setup, and allows you to treat programs as tools, which can be composed and fitted. So, in that sense, it was, it makes things very clean and useful. In fact, most operating systems today are some flavor of this kind of an interface. You also saw how, if I wanted to redirect certain file descriptors to other resources, like, you know, what shell is currently using, then I could do that by inserting appropriate code before the exit system call inside the child container. For example, when I poke something, the semantics of poke are, that the entire file descriptor table of the parent gets copied into the child, right. But, if I wanted to say, if I wanted to say, I want to redirect the output of my child process to some file, let us say, then what I will do is, I will close the existing standard output, and then I will open the file, and once again, the semantics are, then open will return the first available file descriptor in the file descriptor table, which means standard output will get re-initialized to file, and now exec of ls can take place. Notice that in this, I did not have to change the code of ls at all. ls was, you know, it is composable in that sense, because I just changed the environment, and then invoked ls with that new environment, and now ls behaves as exactly as I wanted it to be. One interesting example of composability. This, notice that this is possible, this way of redirection is made very easy, because I have separated this process creation into two system calls. One is the poke system call, and the second is the exec system call, and now I can do some things in the middle, between the poke and the exec system call. It is not very clear, why this is a very, very interesting choice, really, right, because you may argue, well, I am, you know, it is a little faithful to do things in this way, because I first create a copy of myself, using the poke system call, and then overwrite the copy with something else, right. It seems wasteful that I will first copy the entire content, and then completely overwrite it with something else. So, the first copy was really not needed, and why am I doing it? I am doing it, because Unix allows, that is the only way Unix allows me to create a new process, right. It seems it is like, it is a performance problem. However, as I have discussed so far, it gives you a lot of flexibility, right, because you can do things between poke and exec. In fact, Microsoft Windows does not do things in this way, right. So, it does not do poke and exec. It has a system call, called create process. So, I guess, the Microsoft Windows engineers, OS engineers, felt that the poke system call is too costly, and I, we do not really need to, you know, do this. And so, they have, they have a system call, which says, create process, which takes, let us say, a command, arguments. Semantics of the system call are that, it will start a new process, and start this command in that new process. So, there is no poke, right. So, there is no copy being done. And so, you are avoiding that wasteful operation, so-called wasteful operation on units. However, as you can imagine, the new command may need different types of environment. For example, if I wanted to implement shell redirection on something like this, there is no, there is no clear way of how to do it, right. So, if I wanted to say, ls greater than file, who, not quite possible, unless I change the code of ls. So, what they did, was they added more arguments here, like, you know, file descriptor, file descriptors, and so on, environment variables. And so, there are roughly, you know, 10 arguments, this system call. So, you basically, so this system call says, create a process with this command, and these arguments, and this environment, that makes your system call rather bulky, but arguably, it is perhaps more efficient than units. There is a, there is an interesting tradeoff, I mean, here is an example of a tradeoff between clean interfaces, small interfaces, and performant interfaces. Turns out, that units, in its fork and exec, is not all that costly, right. As we are going to discuss later in the course, it is possible to implement poke in a very fast way, right, using what are called copy on write optimizations, where when you create a new process, you do not necessarily copy the entire process up front, but you just create pointers to the original process, with read only, with, and set the entire process read only, in read only mode, and only copy when something is written in the new process. In the common case, when the new process actually just execs to something else, you know, your fork was pretty much free, right. So, interesting example of two real world operating systems doing the same thing in different ways, all right. Okay, last time we saw how shell implements redirection, right. So, the way it implements redirection is that before it calls exec, it closes the standard output, close one, and then, let us say, open foo in write mode, and then, call the exec, have a command there. So, that gives you redirection of command on the shell, right. I could also do something like, less than foo, greater than bar, and let us say, this is the dollar sign. What this is doing is, it is redirecting the standard input to foo, and redirecting the standard output to bar, and you could do it in pretty much the same way as we discussed earlier. You will close the standard input, open foo, close the standard output, open bar, and execute. If I wanted to execute a shell script, all I need to do is, let us say, this is my foo file, it will have, let us say, a few commands, echo one, and echo two. Now, foo can be a shell script, and when I say shell is less than foo, this shell script gets fed as input to my shell, and that gives you shell script execution. Very, very composable. Here, when I said echo one, I did not care about where the data is going. I am basically saying, I want to write it to standard output, and the standard output was actually initialized much later, and that invocation of the shell script foo. Let us say, shell sh is less than foo, it is greater than bar, it basically executes the shell script, and prints one and two on the shell, on the, in the file bar. So, let me just draw the file descriptor table once again. So, let us say, this is a process P1, this is another process P2. There is a file descriptor table that is associated with the process P1. There is a file descriptor table associated with process P2. Process P1 can only access this file descriptor table using system calls. So, I cannot, a process P1 cannot just access this table directly. This table is sort of hidden from the process, and the only way it can actually manipulate or read these tables, is using read, write, open, close system calls. Entry, a single entry in this file descriptor table, points to a structure, which says, where is my resource, then it says, what is the offset of that resource. So, the offset is maintained inside the structure. So, let us say, the resource is a file foo, and then there is an offset inside the structure, which, which says, what is the current pointer at which the file is writing. When I call a system call like write, on file descriptor 1, it basically just starts writing at the current offset of. Another file that wants to write, it is again going to write, append. So, it is going to have, so off is going to get incremented on every write system call, right. That is how, you know, two successive writes, give the feeling of appending to the file. So, that is also part of the semantics of the write system call, that the offset gets incremented on every system call, read or write. Now, let us say, and one, and one, one thing I wanted to point out is, so when a process P1 forks a process, let us say fork P2, then the file descriptor table gets copied. All right. And, and these pointers are shared, right. So, the same structures get shared, and this allows you to do what is called file sharing, right. So, the child could be writing to the same file, and the parent could be writing to the same file, and their outputs would now get intermingled, in any arbitrary order depending on the execution order. You could insert synchronization between your child and the process to decide the order in which you want to write to this file, but in any case, this implements file sharing. There is another way of inter-process communication. One, so you, a process forks another process, the file descriptor table gets copied, the file gets shared, whatever one process is writing is now visible to the other process for reading. However, if process P2, let us say, calls close on file descriptor 1, that may have no effect on the file descriptor table of process P1, right, because the file descriptor tables themselves have been copied. It is the pointers that are being shared here. So, if this process P2 calls close, absolutely no effect on process P1. The shell also allows you to do something like L S A D greater than file POO, and so this means redirect the standard output to file POO, and 2 greater than file bar. It means redirect the standard error port to file bar, right, that is very easy, and you can imagine how this can be implemented, but what it also allows you to do, is it allows you to redirect standard out, error port to the standard output port. So, basically saying, redirect the standard error, whatever is written to the standard error, to the same resource that is being pointed to by standard output. So, that is, the syntax for that on shell is 2 greater than and 1, depends on different shells, but you know, let us say, this is the syntax for redirecting standard output, standard error. How would one do this? How would a shell implement this? Well, one nice way to implement this, is to do the same thing, which is close 1, open POO, close 2, open POO. Seems like a correct way of doing things, let us see what happens. Here is the file descriptor table, when you call close 1 and open POO, this point, this gets initialized to POO and offset 0, and when you call open and open POO, this gets initialized to POO and 0. Now, when the program calls write on standard output, it is going to write to file POO at a certain offset, and then call, write something to standard error, it is going to write POO, and now, what is going to happen is that, they are going to overwrite each other. What you wanted in this command was that, they should get appended, not overwritten. What do you need? Could have been nice in this picture, instead of having something like this, I have something like this. They have a shared offset, and each time they write either to standard output or standard error, the same offset gets incremented. Current set of system calls that we have discussed so far, do not allow this kind of manipulation of the file descriptor table. UNIX has another system call called DOOP, basically means that duplicate this pointer in the file descriptor table. So, the way I am going to implement this is, I am going to say close 1, open POO, close 2, instead of saying open POO, I am going to call DOOP 1. That is going to have the desired effect of having a shared offset between standard output and standard error. Let us look at more interesting UNIX instructions. So, let us say I wanted to, I have a file called file dot text, and I have a utility, which takes the file and sorts it. Let us say there is a utility, there is a program called sort, just like there is a program called shell, and there is a program called LS. There is a program called sort, which takes input from a standard input, and sorts it, and prints the output to the standard output. Let us say what I wanted to do was, I want to first sort all the strings in this file called file dot text. Then, there is a program called UNIX, which takes a sorted file, and eliminates all duplicate entries from that. So, it just retains the unique entries in the file. So, one way to do this is, I sort file dot text, and redirect it to let us say some file temp 1. Then, I UNIX, and call UNIX on temp 1, redirect it to temp 2. Then, let us say I wanted to count the number of unique words in this file. So, there is another command called wc with word count, and I want to say word count less than temp 2, or let us say I just say word count less than temp 2. So, this, the combination of all these three commands is going to count the number of unique words in this file called file dot text. First, sort the file, find the unique elements, and I am going to count the number of words. Of course, I have created two extra files in this process. So, maybe the last thing I need to do is, remove temp 1. And this kind of a thing is also very common, where the output of one program needs to be fed as input to another program, right. This is once again very, very consonant with the concept of tools, where there are multiple tools, and you want to say I want to use this tool, and then feed the output to this tool, and then this tool, and so on, right. I am doing it in this way. Let us say my file is, you know, hundreds of gigabytes or terabytes large. I need a lot of temporary space to be able to maintain this information, number one. Number two, I am writing extra things to the disk, and writes to the disk are generally costly. And so, I am making things very inefficient. I am first writing the whole thing to the disk, and I am reading the entire thing from the disk, then writing another set of data to this, and so on. And this is all very extensive. Ideally, what should have happened is that, I should have had a way on my operating system to specify that here is a program slot, connect its standard, connect its standard input to file.txt, and connect its standard output to the standard input of unique, and then connect the standard output of unique to the standard input of wc, and connect the standard output of wc to whatever is the standard output of the shell, right, because you basically saying this, let us say the shell was executed in the console, you want the output on the console. If I was able to do this, if I was able to specify this, then it would be very nice, because I do not need these extra temporary space, and I do not need extra temporary time to create these things in the space. Once again, this requires manipulation of the file descriptor tables in certain way. And once again, I can, you know, a process is not allowed to manipulate the file descriptor table in any way it likes. By the way, why does not, why is not a process allowed to manipulate its file descriptor table in any way it likes? For security reasons, you know, you are basically saying that the file descriptor tables are referring to shared resources, like the console, the file system, the devices, and the OS needs to interpose on any request made to these resources. So the OS will check on an open, whether this device, whether this process is actually authorized to access this device. For example, if this process is being done by the root user, then it can access certain devices, whereas if it is not running as a root user, it cannot access certain devices. Just with the ways, I mean, so the OS needs to provide gates through which a process can enter. The process cannot just walk over my file descriptor table any way it likes. But now, I need, and then now the OS is basically, the OS designer is basically choosing the right set of system calls, such that the processes are still able to do what they need to do most of the time. Okay. So I want to be able to do something like this, and this, this connection between one file, the output file descriptor on one, and the input file descriptor on another, is facilitated by a system called pipe. Pipe was a very, very, very new concept that UNIX introduced, and very successful since then. Let us see what pipe does. A pipe is a one-way communication channel, right. So here is an example. Let us say, I create an array, which is my FD array of size 2. So there are two FDs in this array, and I call pipe on FD array. This is the syntax of pipe. I am supposed to call the pipe system call on an array of integers of size 2, right. And what it is going to do, is it is going to create two file descriptors in my file descriptor table, and, and put the output end of that file. So what it is going to do, is it is going to create a pipe inside the OS. Once again, this pipe is inside the OS, and the process cannot just access it directly. It has to access it through gate, which our system calls. It creates a pipe, and it assigns two file descriptors to the two ends of the pipe. So for example, it just, let us say this is the file descriptor table. It is a file descriptor table. What it is going to do, is it is going to find the first two available file descriptors in this table. Once again, walking from the top. Assign the first one to the input end of this file, and assign the second one to the output end of the file. Let us say the two file descriptors that were available were 3 and 4. So 3 is going to point to the input, input end of the file, or you know, to the, okay, depending on, so let us take this pipe as the entity. So the output end of the file is the first one, and the input end of the file is the second one. So, so with that in mind, if this program says pipe fdarray, and then it calls write on fdarray fun, let us say it says hello, problem 5, and then it says read fdarray 0 in some buffer buff, let us say its maximum length is whatever 100, then what I am going to get is answer 5, and the string hello written inside buffer. What has really happened is when you called write, it wrote 5 byte on this file descriptor, which meant 5 byte was stuffed into this file, and when you called read on this file descriptor, these 5 bytes were read off the output end of the file, okay. What you have done is, so recall that file descriptors point to resources. So far we have considered resources which are either external, externally facing devices like console or C report, or they are files in the system, which are again, you know, so this is a file system, let us say. Here, a file descriptor is pointing to an internal resource, which is a pipe that is created using the pipe system call, right, and both ends of this resource are internal, right. In case of a console, the output end was in the OS, so the input end was in the OS, and the output end was on the screen, but here the input end is also in the OS, and the output end is also in the OS, that is one way to think about it, right. When I write to the input end of this pipe in FDRA 1, and then read from the output end of this file, I get what I wanted to, I get what I wrote. This does not sound very interesting, I mean, if I am going, if I just write and then I read, what is the point of doing this through a pipe, I could have just, you know, done it internally, I did not have to involve the OS in this. But what this allows you to do is, allows you to do inter-process communication across processes. So as you can imagine, if I call the pipe system call, I have initialized my file descriptor table in this way, and then I call the scope system call, the file descriptor table gets copied to my child, but the pointers remain the same, so they still share the same pipe. Now, the parent writes to the input end of the pipe, and the child reads from the output end of the pipe, you have implemented inter-process communication. So, let us see how this works. I could call pipe FDRA, it is going to create a pipe, right, then I am going to say poke, it is going to duplicate the file descriptor table, when once I duplicate the file descriptor table, the pointers get shared, so the pipe gets shared, right. Then I can say if CID is greater than 0, which means I am the parent, I write to FDRA1, hello, and else if I am the child, then read FDRA0, stop. In this case, the parent writes to the pipe, and the child reads from the pipe. Now, any questions at this stage, everybody understand? Created a pipe, I poked after creating a pipe, which means that the pipe now gets shared. Let us see what happens. Here is process C1, here is the OS, process created a pipe, so the pipe gets created inside the OS space, which means it cannot be accessed directly by the process, but it can be accessed using read and write system calls. Then, you know, this pipe has pointers, which are represented by file descriptors, so this is let us say FDRA0, and this, or FDRA1, and this is FDRA0. Everybody is with me at this point? At this point, the process P1 calls poke, which means another process gets created, P2. The file descriptor table also gets copied, which means that even this process has file descriptors, which point to the same file, same pipe. Now, if this process writes to the input end of this pipe, either P1 or P2 could not read from this pipe. They call, you know, one way to use this is to, for P1 to call write on the, write here, and P2 to call read here, and that way you can pass information between P1 and P2, okay? Right. So, let us look at the example that we had earlier. I wanted to create pipe between sort, unique, and WC program, right? So, I wanted a picture which looked like this, file.txt or standard output connected to standard input of this, and so on. And so, one way to do it is, you call pipe on FDRA, you call poke, and then you say, if it is equal to 0, which means I am executing in the child context, then close the standard output. I want to connect the standard output of my child to the standard input of some other process, right? What I am going to do is, I am going to close the current standard output of the child, and I am going to call dupe on FDRA 1. What it is going to do is, it is going to copy the file descriptor value in FDRA 1, the pointer in FDRA 1 to standard output. So, now the standard output is connected to the input end of the pipe, right? FDRA 1 was the input end of the pipe. So, when I did close 1, and the dupe of FDRA 1, I have connected a standard output of my current process to the input end of the pipe, right? FDRA 1, all right? And then, at some point, I can say, exec command with sort. I am hiding a lot of syntax, just let us understand. When you execute sort, sort is going to write to a standard output, and the standard output happens to be a pipe in this case. Separately, I will connect the standard input of the other process that I am going to poke unique in, and I am going to connect the standard input to the other end of the pipe, and that way I am going to have a communication between sort and unique. The syntax for this on shell is sort less than file dot text pipe, and this is the pipe character on the keyboard. I think it is a sort, and then it says unique, same pipe, and WC. That is exactly what we saw earlier, which means that sort is going to take input from file dot text, pipe it to this pipe, pipe the standard output to unique. Unique is going to take the input from the pipe, and pipe this standard output to WC. WC is going to take its input from the pipe, and pipe this, and print the standard output on the console, that is it. And what I want you to think about after you go back is how we are going to, how the shell will implement this syntax. So, this is the syntax that is provided by shell. It is implemented by the shell using the pipe system call, right, and I want you to write code to be able to do that. It is going to be something very similar to this, where you create a pipe, you fork, and inside the child, you manipulate the file descriptor, so that its standard output now points to the pipe, and then you exit the program that you wanted to execute. So, when I created a file, a pipe, here is the pipe, sort is writing here, and let us say unique is reading from here. What happens, so now there is an interesting scheduling question that comes up, what happens if sort gets to execute a lot, and unique has not even started. Now, sort is just producing a lot of data, and unique has not gotten chance to run. Now, that brings you to the question, how fat is this pipe, or how large is this pipe. So, you know, there are default values to the size of the pipe. Buns, so they, and always there will be a producer to the end of pipe, and there will be a consumer in this pipe. If the producer is producing too much, and the consumer has not even, you know, is not consuming at the same rate, then eventually the pipe will get full, depending on the size parameter, and the size is, you know, typically in few tens of KBs. Once the producer gets full, the operating system can figure this out, because, you know, the only way the program can produce is using the write system call, and so the operating system sees the write system call, it says, where it is going to write, it is writing to this pipe, it figures out that the pipe is full, it says, let us block this process. So, when it blocks this process, it basically means this process will now not get a chance to run, till the pipe has more space. So, that makes things more efficient, right. So, in a way, now sort and unique programs can now dance together, right. So, sort produces something, gets suspended, unique gets a chance to run, unique consumes, pipe gets empty, unique gets suspended, sort runs again, sort unique, sort unique. If the, if the, if the buffer, pipe buffer was very small, you will always have this kind of a scheduling pattern, sort unique, sort unique, sort unique. If the buffer was larger, then it can absorb more things, so it, you know, they can have it happen in any arbitrary order, it can be sort, sort, unique, sort, sort, unique, unique, unique. This, this way of doing things is firstly more space efficient, secondly more time efficient, you do not have to write anything with this, and it also gives you a, gives the operating system nice insight into the scheduling, the right kind of scheduling that should happen for the system to execute at full throughput. Question. So, it may or may not, that is, that is just an optimization, even if it does, right. So, the user can control the size of the pipe, there is a maximum limit that the size of the pipe can be. Pipe on current operating systems are implemented in memory, you never, so an operating system does not typically use the disk to implement the pipe. So, if it is executing, if the pipe is being implemented inside memory, you are automatically bound by the size of the memory, number one, and actually much smaller than that, because you want memory to be available for other things too. So, pipes are typically much smaller than what you could have, if you had, okay. So, what if the pipe is so small, that even one write cannot complete properly, that is no problem. The semantics of write are, that till it writes the entire data, let us say the semantics of write are, till it writes the entire data, it blocks, right. So, if you, if you want to write a 100 bytes, and at 50th byte it got blocked, it just gets blocked. And now, the other, the other process can, should be, somebody, some reader should actually wake up, if any. And if it wakes up, it is going to consume, and so the, so the write has not yet returned, and yet scheduling transfers are taking place, right. Scheduling transfers are not necessarily demarcated by execution inside the application. Scheduling transfers can happen in the middle of the execution of a system call, this thing. So, unique is giving its output to word count, and word count, you know, word count is supposed to compute the count of the entire file, and if it has just received half the word count, then what does it mean really, for word count to, you know, word count cannot really work. So, the way word count program must have been written, is that it is going to read the input, till it reaches end of input, and then it is going to compute something on that input, right. So, till, till unique is producing something, word count is consuming something. Word count will never produce anything, till it has seen the end of input marker. In this case, unique, so sort is producing for unique, and unique is producing for wc, and these programs could be written either in, you know, either in online fashion, which means I read few hundred bytes, or few thousand bytes, or few million bytes, and then I can compute something on that, or they can be written in a way that, you know, I want the entire input, and only then I can compute something on that, in their own application space, right. So, they have allocated buffers, in their own application space, they are going to store it in their application space, and now they are going to compute on it, just like you write a normal program, right. You, you read from a file, you store it in an array, and you compute something on that. So, instead of reading from the file, in this case, you are reading from the pipe. So, read will only return values that have ever been written to the pipe. It will never return any unnecessary garbage values, right, and it will return the values in exactly the same order, in which they were written to the pipe. So, so read will never return any wrong value, really, and if you say, I want to read the next thousand bytes, till thousand bytes are available, let us say the read block, right, or it returns saying, I have not, I have not been able to read, I have only been able to read two bytes, and here are the two bytes, and now the, it is up to the programmer to say, give me the next 998 bytes. How does the OS release the resources for the pipe? Interesting question. Anybody? Close, right. If you close both, if you close the ends of the pipe, if all the processes in the system, so a pipe is associated with the file descriptors of certain processes in the system, right. If you can figure out that, you know, all the ends of this pipe are closed, so no process in the system actually points to this end of the pipe, and the pipe is empty, then you might as well just completely release the resources, because if somebody calls read on that pipe, you can just say that, you know, you can block it, and then nobody is going to write to it. There is no writer to it. So, the pipe, one end of the pipe is completely invisible to the system, and so at that point, you can release the resources. Okay, good. Okay, next. So, pipe is a very interesting Unix abstraction. The next abstraction I am going to talk about are Unix signals, and we are going to do this in the next lecture."}