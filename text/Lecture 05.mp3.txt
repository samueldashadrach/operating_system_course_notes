{"text":"Okay, welcome to Operating Systems Lecture 5. Yesterday we were, we started looking at the hardware interface for an operating system and we started with the x86 architecture and we were looking at the instruction set of the x86 architecture just to get ourselves familiar with all the instructions. And you know, we said that, so we have the syntax of the x86 instructions on this side and this is the AT&T syntax, where the destination operand is the last operand and the source operand is the first operand or you know, if there are three operands, then the first and second operands are the source operands. And you know, there are these different addressing modes which you may have already studied in your computer architecture class. So you can move register to register, this is the register mode, so every instruction can operate in either of these modes. You know, you could very well replace move with add or subtract, it means the same thing. It means the corresponding thing. Move will $0x123, this is the immediate mode, basically means that assign immediate value 123 to this register. Move without a dollar basically means treat this address as a memory address. And so this is the direct memory addressing mode, right, you may have seen it in your computer architecture class. Then you could say, you know, if you bracket the register name like this, then this basically means it's an indirect addressing mode, basically means use the address in EBX to dereference memory and get the contents into the destination operand. In the C equivalent, it basically means EDX is equal to star of EBX, where EBX is treated as a 32-bit, as a pointer to a 32-bit value. And then there's also the displace mode, so you can specify displacement along with the indirect mode, so which basically means that add 4 to EBX and then dereference it. And these displacements or immediate values of memory addresses can be 32-bit byte also in 32-bit mode on x86, right. So you could have a full 32-bit displacement with a 32-bit register value, add them, and then dereference. Okay. All right. So the different types of instructions on x86, there are, let's say, data movement instructions like MOV, PUSH, POP, right. We've already seen MOV. PUSH and POP are instructions that operate specifically on the stack. I'm going to discuss the semantics very soon. Each of these, of course, can be suffixed with a character which indicates what the size of the operand. For example, MOV L basically means a 32-bit operand, and MOV B means an 8-bit operand, and MOV W means a 16-bit operand. So BWL are the, I mean, just syntax of AT&T to specify 8, 16, and 32. Then there are arithmetic instructions like ADD, SUBTRACT, what are, BWL, BWL are just suffixes to opcodes which specify the size of the operand, right. So for example, in this, here, when I say MOV, I'm actually suffixing it with L, which basically means treat these values as 32-bit values, right. If I had instead used B here, it would have meant I'm working on 8-bit values, right. Actually if I say B here, this is an invalid instruction, this is an illegal instruction because I'm specifying 32-bit registers, and I'm using B here, so there's some instructions that are not possible. So L is the only valid legal value here, but if I want to say, for example, MOV W, I would want to say MOV W, AX, BX, right. Often the suffix is inferable from the operand, so for example, if I didn't say W and I just said MOV AX, BX, the assembler would be able to figure out that it's a 16-bit operand, so it will itself, for example, suffix it with W. But for some cases, it may not be possible to infer the operand size. For example, if I have something like, let's say if I have something like MOV $123 to memory address 123, right. It's basically saying move this immediate value to this memory address, right. And there's ambiguity here because you haven't specified the operand size, and it's not possible to infer the operand size from the operands, right. So MOV W will mean treat this as a 16-bit value and store only two bytes to this address, and MOV L would mean treat this as a 32-bit value and move it to, so in such instructions you are required to specify a suffix, otherwise the assembler will say there's some ambiguity in your code, right. How do you address the first 16 bits of a 32-bit register? Well, x86 gives you this ability to say, you know, the first 16 bits of EAX are AX, right. And EBX are BX and so on. You cannot access the top 16 bits of a register directly, okay, not allowed, all right, okay. So add, subtract, you know, then, and we also said that these instructions also set up the E-flag register appropriately, for example, if it's a negative value, et cetera, so they also write the flags, and there are instructions like jump, equal, jump, not equal, jump less, which read the flags to make control flow decisions. And there are also instructions like test, which actually don't do anything, they just set the flags. So test is going to check if a value is equal to zero or not, or things like that. Or you know, you can also have things like shift, shift left or shift right, or rotate left or rotate right, and so on, you know, so there's a huge list of operands that can happen, just to give you a flavor of what. Then there are IO instructions, like in and out, right. So so far what we have seen are basically instructions that do arithmetic or data movement that operate on either registers or memory, but what if I wanted to access a device, there are special instructions which are called IO instructions, and the instructions are in and out, and what they mean and what their syntax is, we're going to talk in a few minutes. Then there are control flow instructions, like jump, you know, jump equal, jump less than, jump greater than, and so on, so lots of different things. And then there are special instructions for function calls. So there's a function, there's an instruction called call, and there's an instruction called return, which are basically equivalent to saying function call and return, and what their semantics are, we're also going to discuss in a few minutes, all right. Okay, and then there are some instructions which are called string instructions. So string instructions are of this type, MOV SB, where SB stands for MOV a byte of a string, right, and this instruction has default operands, the memory address of the, so it's a string instruction which says MOV one byte of data from the memory pointed to by register ESI to the memory pointed to by EDI, all right, so there's a special instruction that can actually do two memory accesses in one instruction. It will read a byte from the address of ESI and write a byte to the address of EDI, right, and the reason this is supported in the x86 architecture is because there are many string operations that are usually done, and you can actually prefix this instruction with what's called a repeat prefix that basically executes this instruction repeatedly, each time incrementing ESI and EDI, so ESI is considered the source address or the source pointer, EDI is considered a destination pointer, MOV SB means MOV a byte from the source pointer to the destination pointer, prefixing it with repeat basically means keep repeating this and each time keep incrementing ESI and EDI till a certain condition is reached, and you can also specify what, under what condition you want to stop. So you can imagine, you know, the hardware designers, what they had in mind was let's say things like string copy, right, so if you want to implement string copy, one way to implement it is to, you know, implement in using many instructions like a for loop which basically, you know, increments a counter in software, but because it's such a common operation, you know, the hardware designer said let's have a special instruction for it, and there's just one instruction which will, for example, do mem copy or string copy or things like that. Okay, just to know, because, I mean, just in case you see this kind of code in your programming assignments, you should know what it means. All right, and then there are, you know, special instructions which we can call system instructions. These instructions are very, are instructions that are required by an operating system. So, so far the instructions we have really talked about are instructions that a user program may require, accessing memory, accessing registers, accessing IO may or may not be allowed for a, for a user, for an application, so even in and out can be considered system instructions in that sense, but then there are special instructions for system which, you know, allow you to, for example, raise an interrupt. What this means is it's going to, it's a, it's called a software interrupt instruction which basically emulates that I have received an interrupt, okay, how it's used, what it means, et cetera, we're going to look at in a moment, but just to give you a flavor of what, what exists, and then there's another instruction called IRED which says return from an interrupt, right, so you can say, you can simulate an interrupt, you can get into the interrupt handler, and then you can have a return from interrupt instruction, okay, never mind, we're going to look at it in more detail in a few minutes. So what do the, you know, in and out instructions mean? Just hold on, we're going to discuss it very soon, all right. Test is an arithmetic instruction that just tests, let's say, your operands to see if they are equal to zero or not, or it adds them and sees what, so I mean, it's an example of an instruction that does not necessarily modify its operands, but sets some flag based on the values of the operands, so often, you know, if you want to execute control flow, you can execute test, and then you can execute jump conditional, too, based on the value of the test, all right. Okay, so we're going to discuss in a, you know, in the next couple of lectures how system calls work, how operating system instructions work, etc., but before that, let's just talk about how function calls work, right, so how do you, when you call a function, what happens, what kind of code is generated by the compiler, and what kind of, you know, so how does it all work inside, just in the context of function calls before we start understanding how things work for a system call, and how does OS do different things, etc., all right, so every process has an address space, right, and in the address space, there is one pointer, which is the stack pointer, or, you know, the 32-bit x86 architecture calls it the ESP, extended stack pointer, right, and this pointer, basically, the semantics of this pointer are that it should, it points to the top of the stack, and so, and the other convention on x86 is that the stack grows downwards, right, so the stack is initialized at some value, and then, you know, if you, if you, for example, call a function, then the stack is going to go downwards, if you allocate a local variable, the stack is going to grow downwards, as you have seen the use of stack in other courses, like programming languages, or architecture, for doing function calls, right, yes, okay, all right, so, okay, so there are some instructions that actually access the stack, so, for example, push, I can push a register onto the stack, or I can push an immediate value, or I can even push a memory operand onto the register, right, so this can be replaced by a register, immediate, or memory, whatever you like, basically means the semantics of this are subtract four, so in this case, it's a push L, because I'm pushing a 32-bit value, 32-bit means four bytes, so it basically means subtract four from ESP, grow the stack downwards, and move EAX to the memory location pointed to by ESP, right, that's what push means, so here's the ESP, you call push, it's going to decrement stack, and it's going to put EAX in that, so in other words, what's going to happen is, if this was ESP, let's say this was ESP, and it's pointing here, then when you call push, what'll happen is, ESP is going to now point here, and this memory location will now contain the contents of EAX, right, similarly, pop, EAX basically has the opposite semantics, so let's say this is ESP, I call pop, EAX, what it's going to do is, it's going to move ESP, contents of ESP, into EAX, and add four, right, so in other words, let's say ESP was pointing here, you executed pop, what's going to happen is, whatever was contained here is now going to go to the EAX register, and stack pointer is now going to point here, so push grows the stack, pop shrinks the stack, right, okay, then there is function call, right, so we looked at, we saw that there's an instruction called call, so I can actually make, say call, you know, some address, one, two, three, four, five, which basically simulates a function call, and so in this case, what happens is, let's say here's a stack, and before this call instruction, ESP was pointing here, so call instruction is going to do what, it's going to push the current EIP, right, notice that no such instruction exists, I'm just using it to explain it to you, what the operations of this are, right, so it's going to push the current EIP, after it has been incremented, so, you know, as soon as the instruction is fetched, the EIP gets incremented, and the incremented EIP is what you push onto the stack, right, and then you jump to, so basically you just push the address of the next instruction onto the stack, and you jump to the destination, right, so in other words, what happens is, ESP gets decremented, stack grows, and this contains the address of the instruction following the call site, the instruction following the call site, right, this is also called the return address, right, you can imagine why you need the return address on stack, because when the function calls return, that's where he's going to jump back, right, so that's what it means, right, when you make a function call, it's going to execute that, and then when it calls return, you're going to come back to the next instruction, so that's where, the way it's done is basically using a stack and a return address code on the stack, right, and then there is the return instruction, basically what it does is, it just pops from the stack, and puts it in EIP, right, once again, this is not a real instruction, I'm just using it to explain what return does, it will increment the stack pointer, which means it will shrink the stack, and whatever the value was there, it's going to put it in the program counter, or the EIP, and so that's where you go next, so it's an indirect branch in some sense, alright, okay, so a compiler usually dictates how the stack is going to be used, right, so a compiler will have some conventions on how the stack will be used in case of a function call, right, so typically you would have different functions in different files, and each function will be compiled separately, and the compiler will have some conventions on how this function body should be organized, such that it can fit in well with the caller, and its colleagues, right, so let's look at what kind of conventions does a compiler have, and let's look at one compiler which is a popular compiler that we all use, is GCC, alright, so GCC says that at entry to a function, EIP will point to the first instruction of the function, right, obviously, when I say call some function name, the next EIP, the next program counter should be the first instruction of that function, right, ESP will point to the return address, okay, so we saw when you say call, the return address automatically gets pushed, and so if you execute call, you know, your GCC is basically just using the same thing as what the call instruction does, right, so if you are inside a function call, as soon as you enter the function call, the program counter is the first instruction of the function, and the stack pointer should be pointing to the return address, right, so if the first instruction of the function is, let's say, return, then you just go back to the return address, alright, and ESP plus 4, right, so this is, as you can see, it's a very 32-bit architecture-specific thing, 4 bytes for the return address, it's assuming that the return address is 4 bytes, and ESP plus 4 should point to what, yeah, the first argument of the function, alright, so in other words, if there's a function foo, and I make a call to foo, at this point, my stack layout must, and let's say the foo takes, you know, two arguments, int a, int star b, then if, at entry to the function, ESP should point somewhere in the address space, wherever it points, this should be the return address, right, and this should be a, right, and this should be b, and so on, right, if there are multiple arguments, they just stack on top of one another, okay, so that's the convention of a compiler, so that's, you know, that it uses, and that's what most compilers will use, that a function, when it starts, it can assume the following things about the stack layout, it can assume that the return address is at ESP, and the first argument is at ESP plus 4, and all the subsequent arguments are above it, right, so it's the responsibility of the caller to set up the stack in such a way, before it calls the function, okay, yes, okay, interesting question, so why is return address, so this is in some sense the top of the stack, right, so why is return address at the top of the stack, and why are the arguments below it, why can't it be the opposite way, yeah, so firstly, the number of arguments is variable, so you know, it's hard for, it's much easier to say that return address is right at the top, because otherwise you have to worry about how many arguments there are, and based on that you have to compute where the return address is going to live, so as opposed to that, because return address is the most common thing that's going to happen, so let's have it at the top, secondly, when you're calling the function, you know, that's when you want to push the return address, right, so you're going to push something, and then you're going to call the function, and that's when you want to push the return address, because after that is the next instruction that needs to be executed, otherwise, you know, I would have to worry about where I have, where I should return, and I have to push that explicitly, so the instruction that pushes the call, that actually makes the call, and pushes the return address should be the last instruction in the caller, okay, so if I have to use A, B, then I have to actually go up, is that right, it's just RAM, right, so I don't have to go up, I just specify an address, I just say 4 plus ESP, so it's actually no less efficient than saying ESP, right, even I can say 100 plus ESPs, it's equal in efficiency, it's just an address computation, all right, yes, okay, so the question is really about ARM and x86, ARM has a link register, and x86 does not have a link register, that's true, why and why not, let's defer that discussion, but x86 does not have a special register where it stores the return address, x86 instead stores the return address on stack, right, other architectures like ARM have a special register where they will store the return address, and now it's the responsibility of the software to actually move that register to the stack in case of nested function calls, right, so that overhead or that extra work from the software is avoided in x86, sure, if you use branch and link, what it does is it sets the return address into LR, the link register, right, and now if you make another function call, nested function call, then before that you have to save the LR onto the stack, okay, so x86 avoids that in some sense, all right, and so that's the entry, at the entry of the function, and after the return instruction, after the return instruction, or after the function return, the stack should be organized as follows, EIP should point to the return address, all right, ESP should point to the arguments that were pushed by the caller, right, all the arguments, right, so at function return, the stack should be exactly as the caller left it before calling the function, right, so I'm basically specifying a contract between the caller and the callee, right, there is a caller which is calling the function and the callee which is being called, right, and there is a contract between the caller and the callee, and that's what I'm specifying here, and ESP should point to the arguments that were pushed by the caller, the function may have trashed, the called function may have trashed the arguments, right, so for example, if I call foo int A, int B, foo is free to change the value of A, all right, and when it returns, the caller shouldn't assume that the value of A is exactly what he had sent it, as it has sent it, it should assume that the stack is laid out in the same way, but it shouldn't make assumptions on the values of the arguments, right, just a convention of the compiler, all right. The other thing is EAX should contain the return value, right, why is B pushed before A, just a matter of convention, okay, there's no reason, one reason potentially could be that some functions that actually allow variable number of arguments, for example, printf allows you a variable number of arguments, and the number of arguments depends on the value of the first argument, which is the format string, right, so to be able to support this kind of thing, you know, the first argument should be right close to the ESP, and all the arguments can be a variable, okay, so question is why doesn't the callee just remove the arguments before returning, why does the caller need to do it, all right, see it doesn't matter whether the caller does it or the callee does it, the amount of work doesn't change, right, the total amount of work doesn't change, it's just easier to organize it in this way because the return address is at the bottom, so the callee just returns, and then the caller can clean up the stack above it, right, so the cleaning of the stack is done in the same order in which the stack was set up, basically, all right, EAX should contain the return value, and then there is another convention which says, you know, certain registers can be overwritten, so for example, EAX, EDX and ECX may be trashed by the callee, and certain registers EBP, EBX, ESI and EDI must contain the same value as at call time, okay, so here is another convention which basically says certain registers are allowed to be overwritten by the callee, certain registers must have exactly the same value as the callee, as at call time, right, okay, so the terminology is these are called caller save registers, and these are called callee save registers, basically means the callee is free to track these values, registers, so the caller must save them before making the call, if it actually cares about those values, right, on the other hand, these registers, the caller has a contract with the compiler that, you know, these are not going to be modified, so it doesn't need to save them, if the callee does need these registers, then it's the responsibility of the callee to save them, and then restore them before returning, okay, so if the caller and the callee follow this contract, apart from that, a function, a call function is allowed to do anything else, it wants, right, the call function can do anything it likes, but it should ensure that on return, EIP will point to the return address that was pushed on the stack, as the stack was set up on function entry, ESP will point to the arguments as I had set them up to be, it may have trashed the arguments, I don't care, EX will contain the return value, these registers I may have overwritten, but these registers must contain the same value as at call time, right, if this contract is followed, you know, I can call different functions, and I don't, and I can compile these functions separately, and call them from one another, and they will all work, they can be hooked together easily, right, they need to follow this contract, apart from that, they can do anything else. In your homework, we'll ask you a question on why do you need separate caller and callee saved registers, why could, why does it make sense to say that some part of the registers should be saved by the caller, and some part of the registers should be saved by the callee, why can't we just say all registers should be preserved, right, in which case all registers become callee saved registers, or conversely, we could have said all registers should be, can be overwritten, may be trashed, in which case all registers become caller saved registers, both these are options, but compilers usually take the middle path, half the registers are caller saved, and half the registers are callee saved, something to think about, right, we're going to discuss that later. Okay, finally, on a function call, so at the entry of a function call, the stack looks something like this, this is the return address, this is argument 1, this is argument 2, and so on, right, and the function now gets to execute. Typically what GCC does is it will also, so the first instruction in the function would basically also save the current EBP value, so call it the saved EBP, right, and so it's going to push EBP, so the first instruction of a function will typically be push EBP, right, let's say this is the first instruction of the function foo, the first instruction is going to push the current value of EBP, and it's going to set the current value of stack pointer to EBP, or move ESP to EBP, right, what's it doing? It's basically saying that, all right, so let's see what happens, I'm going to push EBP, so ESP becomes this, and then I basically say move ESP to EBP, so what happens is EBP becomes this, then the function may have some local variables, and so it's going to allocate some local variables, and the way it allocates local variables are also in stack, so one way to allocate local variables is keep pushing the values if they're initialized, or just subtract a value from the stack, so you know the size of the local variables, if there are like 10 variables, if there are 10 integers in the local variables, then you will just subtract ESP by 40, right, and so ESP will point somewhere here, and you can dereference these local variables by using the appropriate offset in ESP, and EBP is now pointing to the ESP value at the start of the function, right, so in other words, EBP is acting as a frame pointer, and you can use EBP to actually dereference arguments, so if you want to get to argument number 10, then you just say EBP plus 4 plus 10 into 4, right, that's argument number 10, if all arguments are integers, let's say, so it acts as a frame pointer, and the saved EBP is the frame pointer of the caller, right, the saved EBP is the frame pointer of the caller, so I made a call at the entry of the function, the EBP value would still be the frame pointer of the caller, I first save the frame pointer of the caller, then I modify the frame pointer to my own frame pointer, I just modify EBP to my own frame pointer, and now I start allocating local variables, right, so that's at entry, and before I return, what do I need to do, I need to do the opposite, which is what, let's say, move EBP to ESP, so I want to reset the stack, exactly, so I may have grown the stack a lot, I may have allocated lots of variables, I may have called lots of functions, and now, you know, one single instruction way of resetting the stack is just to say, move EBP to ESP, because EBP is containing my frame pointer, so if I just say move EBP to ESP, I reset the stack back up, and then I just say, pop L EBP, that's going to restore the saved EBP to my EBP, so I get the caller's EBP back into the EBP register, and then I say return, right, so I go back to the caller, so in this way, I save the EBP value, I clobber the EBP value in my code, I write over it, I clobber it, and then, before I return, I just pop it back, so recall that EBP was a calling saved register, and so the contract is that EBP should be exactly the same as I gave it to you, right, and so this mechanism is actually doing that for you, so this is a typical GCC behavior, that you will save the frame pointer of the previous caller, and you will initialize the new frame pointer, and before returning, you're going to restore the frame pointer of your caller, what this allows you to do, things like, you know, looking, debugging things, like you can look at the backtrace of the current call chain, so for example, if I want to say, how many of you have used the backtrace command on GDP or something, for the first homework you've used it, right, so backtrace just tells you what is the call chain, right, so who called whom, who called whom, who called whom, and how am I here, and that's basically done using this frame pointer and saved EBP thing, right, so what it does is, it looks at the current EBP, so firstly it looks at the current EIP, and from that it knows in which function I am, then it looks at the current EBP, and from that it just displaces it by 4 to get its return address, and from the return address it knows its caller, right, and from that it also knows the saved EBP of the caller, and from that he recurses, right, so he can just do that over and over, so he gets, he has the capability of getting the frame pointer of all his callers, based on this recursion, right, I just look at my EBP, dereference it, I get the EBP of my caller, I look at that EBP, dereference, I get the EBP of its caller, and so on, right, and plus, if I dereference plus 4 of it, I also get the return address, so with each frame pointer I also have the return address, and that's how I basically have the call chain of the entire, so that's how the backtrace command, for example, is implemented on GDP. How does this call chain end? Well, you know, you could just have a terminating EBP value, let's say it's a 0, at some saved EBP is 0, for example, at main, so you know, you could just have some convention that this EBP is going to terminate. Okay, and also notice that EBP was not strictly needed. Now, apart from debugging purposes, what am I using EBP, what am I using EBP for? What am I using frame pointer for? I'm using it to reset the stack, number one, but resetting the stack I could have done anyways, right, because I know how many arguments I've pushed, I just need to pop that many arguments, you know, or how, if I incremented it by 40, or decremented by 40, I just need to increment it back by 40, so I didn't really need EBP to reset the stack. The second thing I'm using EBP for is to get to the arguments, right, so I say EBP plus 4 is argument number 1, EBP plus 8 is argument number 2, etc., but even that is not necessarily needed, because the compiler knows that at this point, ESP is, you know, 70 bytes away from the frame pointer, and so, because the compiler has the static information, all it needs to do is add 70 to ESP, and then add, you know, 4 or 10 or whatever to get to the argument. So EBP is not strictly needed, but it's a convenient way of doing things, it aids debugging. Yes? Okay, so what if the called function, the callee, overrides the return address, or overrides the saved EBP, so that, then he's violating the contract, okay, so that's a bug in your function, right, if you are supposed to be accessing your local variables, and your program could potentially access the saved EBP, that's a bug in your program, in your function, unless it was intended that way, right, and in fact, such bugs have existed historically in a lot of our programs, and such bugs have been used to, so the question is, if I'm accessing a local variable, let's say the local variable is an array, and then I offset into an array, and the offset happens to be bigger than the size of the allocation, and so now I can actually clobber my EBP, saved EBP, or return address, and things like that, and based on that, I can actually change the execution control flow, but let's say I clobbered the return address, I can actually jump somewhere else, and this is a very common attack called the buffer overflow attack, and such attacks have existed, and basically this means that there was a bug in your code, what you should have done was, before dereferencing, you should have checked the size, right, so the code should really check the size before dereferencing, always. That's a safeguard that all code must take, and such bugs have existed, but people are much more aware today, and such bugs are much rarer. Okay. All right. Finally, let's talk about a compiler workflow, just to complete this discussion. A compiler has a preprocessor, which takes your source program, which has these hash include or hash define directives, and preprocesses them, so it's really a source-to-source transformation. It takes C code, which has these hash define directives, and just produces another C code, right? So it actually doesn't look at the syntax at all, it just does macro expansion. It just replaces that hash define variable with its value, or expands hash include with the contents of that file, and so on, right? So that's a preprocessor. Then there's a compiler that takes a source file, parses it, and generates an assembly code, right? Assembly code is something that we have seen so far, like all these human readable assembly code, like moveL, addL, and so on, you know, with their arguments. So compiler basically parses C syntax, and generates assembly code, right? Then there is an assembler that takes the assembly code, which is a string which a human can read, and emits binary code that a machine can read, right? That's an assembler. The binary code is stored in .o files, which are called object files. Compiler emits .f files, which are assembly files. So it gets assembled into a binary code. These are called object files, machine-readable code. And then there is a linker, which takes multiple object files, combines them to make one executable, in or out. You could have multiple source files. Each source file gets compiled to an object file. These files could have independent functions, like foo, bar, et cetera, as long as they follow the function calling contract, it's okay. Foo can call bar in different files. And the linker is going to ultimately link them all, and make them, and patch all these references between foo and bar, right? And then there's the loader. Loader takes the a.out, and starts it running, right? So where have we seen the loader before? In the exec system call, right? So when you call the exec system call, you basically give the name of the executable file. And inside the OS, there is a loader that will load that file. The file should be in a certain format. And that file is going to now get pasted into the memory space of that process. And you will start it running by transferring control to the first instruction of that process. So that's the job of the loader. So that's the workflow of a compiler, a linker, and a loader, right? So let's stop here, and we'll continue next time."}